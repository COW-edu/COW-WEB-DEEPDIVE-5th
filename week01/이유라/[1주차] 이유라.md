## 1장. Background

이번 COW Web-deepdive 파트에 참여하면서 TypeScript에 대해 공부해 보고자 한다. <br> 본격적으로 공부하기 전, 타입스크립트를 왜 배워야 할지부터 타입스크립트의 등장 배경부터 정리했다.

<details>
<summary>타입스크립트를 왜 배워야 할까? </summary>

- **오류 예방**

  - 컴파일 단계에서 타입을 검사함으로써 애플리케이션 실행 단계에서 발생할 수 있는 오류를 사전에 발견할 수 있다.

- **타입 명시에 대한 이점**

  1. 타입 지정으로 인해 코드의 의미를 명확히 할 수 있어, 코드 가독성과 유지보수성이 향상된다.
  2. 코드의 의도를 명확히 전달할 수 있어 협업 효율성을 높일 수 있다.

- **자바스크립트와 호환**
  - 타입스크립트는 자바스크립트와 100% 호환되기 때문에 자바스크립트가 사용되는 어느 프로젝트든 사용이 가능하다.
  - 이때 주의해야 할 점은 타입스크립트 코드가 모든 자바스크립트에서 호환되지 않는다는 점이다.
    - TS는 JS의 상위 집합이기 때문에, JS는 모두 TS로 옮겨올 수 있지만 그 반대는 항상 가능하지 않다. 특히, JS에서는 타입 문법 자체가 없기 때문에 TS 전용 문법은 JS에서 실행되지 않는다.

</details>

<br/>

<details>
<summary>타입스크립트의 등장 배경</summary>

### 1. 자바스크립트의 탄생

- 1995년, 넷스케이프의 브랜든 아이크가 Self의 프로토타입 기반 상속 개념과 Scheme의 일급 함수 개념을 차용해 경량의 프로그래밍 언어인 자바스크립트를 만들었다.

### 2. 표준 자바스크립트의 필요성 증가

- 1990년대에는 MS사의 인터넷 익스플로러와 넷스케이프의 넷스케이프 내비게이터가 가장 많이 사용되는 웹 브라우저였다.
- 둘의 DOM 구조가 달라 크로스 브라우징 이슈가 빈번했고, 자바스크립트와 브라우저의 발전 속도 차이도 문제였다.
- 이를 해결하기 위해 넷스케이프는 자바스크립트 기술 규격을 제출했고, Ecma 인터내셔널이 표준화를 진행했다.

### 3. 웹 애플리케이션으로의 전환

- 자바스크립트의 표준화로 정적 웹사이트에서 동적 웹 애플리케이션으로 발전함.
- **웹사이트(Website)**: 사용자와 상호작용하지 않는 정적 콘텐츠.
- **웹 애플리케이션(Web Application)**: 사용자와 상호작용하며 동적으로 콘텐츠를 업데이트함.

### 4. 대규모 웹 서비스 개발 등장

- 컴포넌트 단위 개발이 등장하고, 비동기 요청으로 부분 데이터 로딩 가능해짐.
- **CBD(Component Based Development)** 방식:
  - UI를 데이터에 맞게 컴포넌트로 나누고 조합.
  - 컴포넌트 간 의존성을 최소화해야 함.
  - **의존성**: 의존하는 대상의 변경에 영향을 받을 수 있는 가능성.

### 5. 대규모 프로덕트 개발에서의 자바스크립트의 한계

- **동적 타입 언어** 특성으로 런타임까지 타입 오류를 알기 어렵다.
- 예: `sum("1", "3")` 같은 호출에서도 에러가 발생하지 않음.

### 6. 한계 극복을 위한 해결 방안

- 다양한 자바스크립트 인터페이스 등장: `JSDoc`, `propTypes`, `Dart`
  1. **JSDoc**: 주석 기반이라 강제성 부족
  2. **propTypes**: 리액트 전용, 전체 애플리케이션 커버 불가
  3. **Dart**: 새로운 언어지만 생태계 파편화 우려

### 7. 마침내 타입스크립트의 등장

- MS가 자바스크립트의 **슈퍼셋** 언어인 타입스크립트를 공개.
- 복잡한 웹 애플리케이션을 안정적이고 생산적으로 개발할 수 있게 됨.

  \*슈퍼셋(Superset) : 기존 언어에 새로운 기능을 추가해 확장한 언어로, 기존 코드와 호환되며 컴파일러 등을 통해 실행된다.

#### 타입스크립트의 장점

1. **안정성 보장**

   - 정적 타이핑으로 컴파일 단계에서 타입 에러 방지

2. **개발 생산성 향상**

   - VSCode 등 IDE에서 자동 완성 및 타입 추론 제공

3. **협업에 유리**

   - `interface`, `generic` 등을 통해 코드의 의도 명확화

   \*_인터페이스_: 객체 구조를 정의하는 타입. 해당 구조를 따르게 강제함.

4. **자바스크립트에 점진적으로 적용 가능**
   - 자바스크립트의 슈퍼셋이기 때문에 점진적 도입이 가능함

</details>

## 2장. 타입

타입스크립트가 등장한 이유는 사람이 이해하기 쉬운 방식으로 코드를 작성하기 위해서가 아니라 자바스크립트의 컴파일타임에 런타임 에러를 사전에 잡아내기 위함이다. 따라서 자바스크립트는 그 자체로 언어지만 타입스크립트는 자바스크립트에 타입이라는 레이어를 끼얹은 일종의 템플릿 언어(Template Languages) 혹은 확장 언어(Extensions)로 보는 견해도 존재한다.

<details>
<summary>2.1. 타입에 대한 이해</summary>

#### 1. 자료형으로서의 타입

- 값의 종류를 명시할 수 있어 메모리를 효율적으로 사용할 수 있다.
- 변수 선언은 메모리 공간에 특정 크기의 값을 저장하기 위한 것이다.
- 값의 크기를 명시하면 메모리를 적절히 할당하고, 값의 손상 없이 참조 가능하다.
- 자바스크립트는 아래의 7가지 데이터 타입을 정의한다:

  > | undefined | null | Boolean |
  > | String | Symbol | Numeric (Number, BigInt) | Object |

  \*변수: 값을 저장할 수 있는 공간이자, 값을 가리키는 상징적인 이름

---

#### 2. 집합으로서의 타입

- 타입은 수학의 집합처럼 유효한 값을 정의하는 개념이다.
- 유효한 값의 범위를 제한하여 **런타임 오류를 방지**할 수 있다.
- 타입 시스템이란 코드에서 유효한 값만 허용되도록 하는 **규칙 집합**이다.

타입 시스템의 종류:

1. **명시적 타입 시스템**: 타입을 직접 명시해야 함
2. **타입 추론 시스템**: 컴파일러가 자동으로 타입을 추론함

---

#### 3. 정적 타입과 동적 타입

- **정적 타입 (Static)**: 컴파일 타임에 타입 결정 (C, Java, TypeScript)
- **동적 타입 (Dynamic)**: 런타임에 타입 결정 (Python, JavaScript)

> 💡 **컴파일타임 vs 런타임**
>
> - **컴파일타임**: 소스 코드를 기계어로 변환하는 단계
> - TypeScript는 `.ts` 파일을 JavaScript로 변환하는 **트랜스파일(transpile)** 언어이다.
> - 컴파일 과정은 다음과 같이 수행된다.
>   1. **타입 검사**: 코드에 명시된 타입 또는 추론된 타입이 유효한지 검사
>   2. **에러 확인**: 타입 오류나 문법 오류가 있는지 확인
>   3. **JavaScript 코드로 변환**: 브라우저나 Node.js에서 실행 가능한 표준 JavaScript로 변환
> - ⚠️ TypeScript는 **런타임에는 존재하지 않으며**, 컴파일 후 **오직 JavaScript 코드만 실행**된다.
> - **런타임**: 프로그램이 실제로 메모리에 올라가 실행되는 시점

---

#### 4. **강타입과 약타임: 암묵적 타입의 변환이 이루어지는가?**

암묵적 타입 변환 여부에 따라 타입 시스템을 강타입과 약타입으로 분류한다. 암묵적 변환은 명시적으로 타입을 변환하지 않아도, 다른 데이터 타입끼리 연산을 할 수 있는 편리함을 제공하지만 개발자의 의도와 다르게 동작할 수 있어 예기치 못한 오류가 발생할 수 있다.

1. 강타입(Strongly type)
   - 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 또는 인터프리터에서 에러가 발생한다.
   - 예) Python, Ruby, TypeScript
2. 약타입(Weakly type)
   - 서로 다른 타입을 갖는 값끼리 연산하면 컴파일러 혹은 인터프리터가 내부적으로 판단해 특정 값의 타입을 변환하여 연산을 수행한다.
   - 예) C++, Java, JavaScript

</details>
<br>
<details>
<summary>2.2. 타입 시스템</summary>

<details><summary>타입 시스템의 종류</summary>

1. **타입 애너테이션 (Type Annotation)**

   - 변수, 상수, 함수의 인자나 반환값에 타입을 명시
   - 예시: TypeScript, Java

2. **덕 타이핑 (Duck Typing)**

   - "오리가 꽥꽥거리면 오리다"는 원칙
   - 객체의 **이름이 아니라 "형태(속성과 메서드 유무)"를 기준**으로 타입을 판단한다.
   - 즉, **어떤 타입에 필요한 속성만 모두 갖추고 있으면** 그 타입으로 인정된다.

- 예시: JavaScript

  ```ts
  type Person = { name: string };

  function greet(person: Person) {
    console.log("Hello, " + person.name);
  }

  const user = { name: "Alice", age: 30 };
  greet(user); //  Person 타입에는 'name'만 있으면 되므로 허용된다.
  ```

3. **구조적 타이핑 (Structural Typing)**

   - 타입의 이름이 아닌 구조(멤버)로 타입 관계를 결정
   - 예시: TypeScript

4. **구조적 서브타이핑 (Structural Subtyping)**
   - 구조가 같으면 이름이 달라도 호환됨
   - 서브타입은 슈퍼타입의 모든 속성을 포함

```tsx
const x: string | number = "hello"; // string과 number의 합집합 타입
```

</details>

<details><summary>TS는 왜 구조적 타이핑을 따를까?</summary>

- 타입 시스템의 종류
  자바스크립트는 덕 타이핑(duck typing)을 기반으로 하기 때문에, 타입스크립트는 이러한 동작을 그대로 모델링한다. 명목적 타이핑은 타입의 동일성(Equivalence)를 확인하는 과정에서 구조적 타이핑에 비해 더 안전하다. 하지만 타입스크립트는 자바스크립트를 모델링한 언어이기 때문에 구조적 타이핑을 따를 수밖에 없었다.

이러한 타입스크립트의 특징으로 추가 속성을 가진 객체를 할당할 수 있다는 점이 있어 문제가 발생하기도 하며, 이러한 한계를 극복하고자 타입스크립트에 명목적 타이핑 언어의 특징을 가진 유니온(Discriminated Unions)과 같은 방법이 생겼다.

</details>

<details><summary>TS는 점진적 검사를 한다</summary>
타입 스크립트는 점진적으로 타입을 확인한다. 타입 선언이 생략되면 동적으로 검사를 수행하여 암시적 타입 변환이 발생한다. 따라서 타입스크립트는 컴파일타임에 프로그램 내의 모든 타입을 알고 있을 때 최상의 결과를 보여준다. 하지만 점진적 타이핑이라는 특징 덕분에 JS 코드를 TS 코드로 마이그레이션할 때 용이하기도 하다.

> \*점진적 타입 검사: 컴파일 타임에 타입을 검사하면서 필요에 따라 타입 선언 생략을 허용한다.

</details>

<details><summary>타입스크립트는 슈퍼셋이다</summary>
타입스크립트는 자바스크립트의 슈퍼셋이다. 기존 자바스크립트 코드에 정적인 타이핑을 추가한 것으로서 모든 자바스크립트 문법을 포함하고 있다. 이때, 자바스크립트 런타임에서 type으로 선언된 내용이 제거되기 때문에 값 공간과 타입 공간은 서로 충돌하지 않는다. 따라서 타입과 변수를 같은 이름으로 정의할 수 있다.

<br>

- 주의 <br>

1. 값과 타입의 구분은 맥락에 따라 달라질 수 있다. <br>

   - 예시) 객체 구조 분해 할당

     ```tsx
     //잘못된 코드
     //값의 관점에서 Person과 string이 해석된다.
     function email({ person: Person, subject: string }) {
       //  ...
     }
     ```

     ```tsx
     //올바른 코드
     // 값과 타입을 구분해서 작성한다.
     function email({
       person,
       subject,
       body,
     }: {
       person: Person;
       subject: string;
       body: string;
     }) {
       //  ...
     }
     ```

2. 값과 타입 공간에 동시에 존재하는 심볼도 있다.

   - 클래스(Class)와 enum이 대표적인 예시이며, 이 추후 다른 주차에서 깊게 공부해 볼 예정이므로 이러한 경우가 있다는 사실을 짚고 넘어가면 좋다.

</details>

<details><summary>타입 확인 방법</summary>

- `typeof`
  - 연산하기 전에 피연산자의 데이터 타입을 나타내는 문자열을 반환한다.
  - 반환값은 총 10가지로 다음과 같다.
    - Boolean, null, undefined, Number, BigInt, String, Symbol
    - Function
    - 호스트 객체
    - Object 객체
- `instanceof`
  - 특정 객체가 어떤 **생성자 함수(클래스)** 로부터 생성되었는지를 검사할 때 사용한다.
  - 주로 참조 타입(배열, 사용자 정의 객체 등)의 **인스턴스 확인용**으로 사용된다.
  - 예시:
    ```ts
    const arr = [];
    console.log(arr instanceof Array); // true
    ```
  - 참고: `instanceof`는 프로토타입 체인을 기준으로 검사하기 때문에, **기본형(숫자, 문자열 등)** 에는 적합하지 않다.

</details>

</details>
<br>
<details><summary>2.3. 원시 타입</summary>

타입스크립트는 자바스크립트의 슈퍼셋이기 때문에 서로 차이점이 존재한다. 타입스크립트는 변수에 타입을 지정할 수 있는 타입 시스템 체계를 구축한다. 특정 타입을 지정한 변수에는 해당 타입의 값만 할당할 수 있다.

- 원시 타입 vs 원시 래퍼 객체
  - 자바스크립트의 7가지 원시 값은 타입스크립트에서도 원시 타입으로 존재하며, **소문자**로 표기한다.
  - 원시 래퍼 객체는 **대문자(파스칼 표기)** 로 표기한다.
    - 파스칼 표기법 자체는 객체 타입을 의미한다.
  - 예시
    - `string`과 `String`은 타입스크립트에서 완전히 다른 타입이다.
- 원시 타입 7가지

  | 타입        | 설명                                                                        |
  | ----------- | --------------------------------------------------------------------------- |
  | `boolean`   | `true`와 `false` 값을 할당한다.                                             |
  | `undefined` | 값이 정의되지 않았다는 의미이다.                                            |
  | `null`      | 빈 값을 할당할 때 사용한다.                                                 |
  | `number`    | 자바스크립트의 숫자에 해당하는 원시 값을 할당한다.                          |
  | `bigInt`    | ES2020에서 새로 도입, `Number.MAX_SAFE_INTEGER`보다 큰 값을 처리할 수 있다. |
  | `string`    | 문자열을 할당한다. (공백 포함)                                              |
  | `symbol`    | 중복되지 않는 유일한 값을 할당한다.                                         |

  ***

- **주의할 점**

1. `null`과 `undefined`는 엄연히 다르다!

   - `undefined`는 **변수는 선언되었지만 값이 할당되지 않은 경우**를 의미하며, 자바스크립트 엔진이 자동으로 부여하는 값이다.
   - `null`은 **명시적으로 "아무것도 없다"는 의미로 사용자가 직접 할당**하는 값이다.
   - 예를 들어, 함수에서 매개변수가 전달되지 않으면 `undefined`, 의도적으로 "초기화된 빈 값"을 표현할 때는 `null`을 사용한다.
   - 실제 사용에서는 **API 응답에서 값이 없음을 표현할 때 `null`**,  
     **초기화 전 상태 또는 생략된 값은 `undefined`**가 더 일반적이다.

2. `strictNullChecks` 옵션
   - 해당 옵션을 활성화하면 사용자가 **명시적으로** 해당 타입에 `null`이나 `undefined`를 포함해야만 `null`과 `undefined`를 사용할 수 있다.

</details>

<br>
<details><summary>2.4. 객체 타입</summary>

원시 타입에 속하지 않는 모든 값들은 객체 타입으로 분류된다. 타입스크립트에서는 객체마다 개별적으로 타입을 지정한다.

1. `object`
   - 자바스크립트 객체에 대응하는 타입 시스템이다.
   - 원시 타입에 해당하는 값은 `object` 타입에 속하지 않는다.
   - ⚠️ 사용 지양이 권장된다.
     - `any` 타입과 유사하게 객체에 해당하는 모든 타입 값을 유동적으로 할당할 수 있어 정적 타이핑의 의미를 퇴색시킬 수 있다.
2. `{}`

   - 중괄호(`{}`)는 자바스크립트에서 객체 리터럴 방식으로 객체를 생성할 때 사용된다.
   - 타입스크립트에서 객체를 타이핑할 때 사용한다.
   - ⭐️ 기억할 점

     - 자바스크립트에서 `const obj = {};` 와 같이 빈 객체를 생성하는 것처럼, 타입스크립트에서도 `{}`를 사용하여 빈 객체라는 의미로 사용할 수 있다.
     - 하지만 `{}` 사용보다 유틸리티 타입으로 `Record<string, never>`처럼 사용하는 게 더 바람직하다고 한다.

     <br>

     - 추가 공부:
       > - **`Record<string, never>`이 `{}`보다 나은 이유**: `{}`은 사실상 실제로는 **모든 non-null 값(`number`, `string`, `boolean`, `symbol` 등)을 허용**하기 때문에 완전히 "빈 객체"만 의미하지 않는다. 따라서 의도치 않은 값이 들어갈 가능성이 있다. 반면, `Record<string, never>`은 속성이 존재하지 않는 빈 객체를 표현하기 때문에 진짜 빈 객체만 허용하려면 이 편이 더 바람직하다.
       > - `Record<K, V>`: 키가 K이고, 값이 V인 객체를 표현하는 타입이다.
       > - `never` 타입: 어떤 값도 가질 수 없는 타입을 말한다. throw 사용으로 인한 에러 처리나 무한 루프 등을 표현할 때 사용된다.

3. `array`
   - 타입스크립트에서 배열 타입은 하나의 타입 값만 가질 수 있다.
     - 이는 자바스크립트에서 배열 안에 타입 제한 없이 다양한 값을 삽입할 수 있는 것과 달리 더 엄격한 모습을 보여준다.
   - 원소 개수는 타입에 영향을 주지 않는다.
   - 선언 방식
     1. `Array`키워드 사용
     2. 대괄호(`[]`) 사용
   - ⚠️ 주의할 점: 튜플도 대괄호를 사용한다.
4. type과 interface 키워드
   - object 대신 type과 interface로 객체를 타이핑하는 것이 더 바람직하다.
   - 반복적으로 사용되어도 중복 없이 타입을 사용할 수 있다는 장점이 있다.
   - 둘을 사용하는 기준 (권장)
     - Interface
       - 전역적으로 사용할 때
       - `extends`나 `implements` 사용
     - type
       - 작은 범위 내 한정적으로 사용할 때
       - 유니온 타입이나 교차 타입 등의 기능 활용 시
5. function
   - 함수도 일종의 객체로 간주되지만 function이라는 별도 타입으로 분리할 수 있다.
   - ⚠️ 주의할 점
     1. 자바스크립트에서 typeof 연산자로 확인한 function이라는 키워드 자체가 타입으로 사용되지 않는다.
     - 자바스크립트에서 `typeof`를 함수에 사용하면 반환되는 문자열은 "function" 이다. 하지만 타입스크립트에서의 반환은 문자열이 아니라 함수의 타입 표현식이다.
       - 타입스크립트에서의 반환 예시: `(name: string) => void`
     2. 함수는 매개변수 목록을 받을 수 있어서 타입스크립트에서는 매개변수도 별도 타입 지정이 필요하다.
     3. 반환값 역시 타이핑이 필요하다.
   - ⭐️ 특이점: 함수 자체에 타입 지정하기
     `type add = (a: number, b: number) ⇒ number;`
     - 함수 자체의 타입을 명시할 때는 화살표 함수 방식으로 호출 시그니처를 정의한다.
     - 함수 타입은 해당 함수가 받는 매개변수와 반환값의 타입으로 결정된다.

</details>
