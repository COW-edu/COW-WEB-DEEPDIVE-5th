# 3/30 타입스크립트 내용정리 (93까지 읽음)

날짜: 2025년 3월 30일

# 타입스크립트란?

자바스크립트는 동적타입 언어인데 동적타입 언어는 언어가 알아서 데이터의 타입을 판단하는 특징을 가진다 이러한 특징으로 코드를 편하게 작성할 수 있지만 이에 따른 오류가 발생할 수 있는데 그 오류는 다음과 같다

```jsx
function add (a + b) {
  return a + b ;
  }

  add(100) //NaN
  add(1, '1') //2
```

위 예시함수와 같이 자바스크립트 에서는 하나의 파라미터 값을 가져도 바로 오류가 발생하지 않고 코드 자체가 실행된다 만약 복잡한 코드에서 이런 오류가 발생한다면 정말 값을 찾기 어려울 것이다..

본인도 이번 겨울방학에 프로젝트를 진행하면서 api 코드에서 받아오는 데이터 타입이 달랐어서 발생하는 오류가 있었어서 많이 고생했었다… 트랙 아이디가 숫자열을 가져왔어야 하는데 문자열을 받아와서…ㅠㅠ

(진작에 타입스크립트를 알았더라면..)

## 타입스크립트의 등장

이러한 문제를 해결하기 위해 자바스크립의 슈퍼셋 언어인 타입스크립트가 등장했다!

슈퍼셋 언어란? : 기존 언어에서 새로운 기능과 문법을 추가해서 보완, 향상 하는것을 말한다. 그 덕에 기존언어와 호환되고 컴파일링 될 때 기존 언어로 바뀌어서 컴파일링 된다

# 타입

1. 자료형으로서의 타입
   1. 여러 종류의 데이터를 식별하는 분류 체계로서 사용됨, 메모리에 저장된 값의 개념, 데이터를 해석할 때 사용 되는 방식
      undefined, null, Boolean, String, Symbol, Numeric, object 이렇게 크게 7가지 형태이다.
2. 집합으로서의 타입

   1. 집합으로서의 타입은 값이 가질 수 있는 유효한 범위의 집합 이라고 하는데 이게 무슨 뜻이냐면
      컴파일러 또는 개발자가 이 데이터가 어떤 값을 받아오고 이 데이터로 무엇을 할 수 있는지 알려주는 역할을 한다
   2. 이런식으로 이상하다는걸 쉽게 알 수 있다

   ```jsx
   const num : number = 1;
   const str : string = '1';

   const add : (n : number) => { 더하기 계산 };

   add(num) // 이상없음
   add(str) // 이상함

   ```

3. 정적, 동적 타입
   1. 동적타입의 대표적인 언어인 자바스크립트 에서는 언어가 유연하지만 그에 맞게 단점도 있다. 사용하는 입장에서는 편하지만 런타임에서 타입에 대한 오류를 안잡아서 얘가 연산 함수에 문자열을 넣어도 연산돼서 NaN 이런 값을 내버린다. 이와같이 안정성이 떨어진다는 특징이 있다
   2. 정적타입은 대표적으로 자바 , c 이런게 있는데 얘네들은 모든 변수들의 타입이 컴파일단계에서 정해진다
   3. 동적 타입과 정적 타입의 차이점 : 변수의 데이터 타입이 언제 정해지느냐 차이가 있다. 동적의 경우 런타임, 정적타입의 경우 컴파일단계
4. 강타입, 약타입
   1. 런타입에 타입이 자동으로 변환되는것을 ‘암묵적 타입 변환’이라고 함 여기서 변환 여부에 따라 강타입과 약타입으로 나누어진다
   2. 강타입 : 서로 다른 타입의 값끼리 연산을 시도할 때 컴파일, 인터프리터에서 에러가 발생함
   3. 약타입 : 다른 타입의 값끼리 연산을 시도하면 컴파일러, 인터프리터가 알아서 판단해서 타입을 변환한 후 연산수행 그 이후 값 도출 ex) 자바스크립트 에서의 1 + ‘1’ = 2 로 나오는 예시가 있다.

## 타입 시스템

타입스크립트에서의 타입 시스템

1. 타입 애너테이션 방식

   1. 변수, 상수에 대해서 타입을 명시해주는 방법
   2. 장점으로는 자바스크립트에서 점진적으로 타입스크립트로 코드를 변화할 수 있다는 장점이 있고 단점으로는 타입스크립트에서는 :타입 을 제거해도 코드가 정상적으로 작동하기 때문에 혼동을 줄 가능성이 있다.
   3. 예시)

   ```jsx
   //자바
   int a = 1 ;
   //타입스크립트
   let a : number = 1;
   ```

2. 구조적 타이핑

   1. 타입을 이름으로 구분하고 컴파일 이후에도 타입이 남아있는 이러한 방법을 명목적 구체화 타입 시스템이라고 부른다.
   2. 특징으로는 서로 다른 클래스 끼리 상속관계, 인터페이스가 없으면 타입은 서로 호환이 안된다.

   ```tsx
   //자바
   class Animal {
   	Stirng name ;
   	int age
   }
   class Anime {
   	Stirng name ;
   	int age
   }
   Animal a = new Animal();
   Anime b = new Anime();

   a = b //오류발생

   //ts 인터페이스 사용법
   interface Developer {
   	faceValue : number;
   }

   interface BankNote{
   	faceValue : number
   }

   let developer : Developer = {faceValue : 52};
   let bankNote : BankNote = {faceValue : 3000};

   developer = bankNote ;
   bankNote = developer ; //둘 다 만족
   ```

   하지만 만약 인터페이스가 다른 값을 가지고 있다면 당연히 호환이 안될것이다.

   이게 기존 정적언어는 해당 클래스, 인터페이스, 타입명이 같아야만 호환이 된다. 하지만 타입스크립트는 다르다 타입스크립트는 구조로 타입을 구분하기 때문에 다른 인터페이스라도 타입이 같다면 예시코드처럼 서로 할당할 수 있다

3. 구조적 서브타이핑

   1. 앞서 말한것처럼 ‘집합으로서의 타입’ 이 부분이 타입스크립트의 타입에 해당한다. 즉 타입스크립트에서 타입이라는건 수많은 집합에 포함되는 값 중 하나이고 그 값들도 많은 집합에 포함이 될 수 있다는 의미이다.(즉 교집합이 생길 수 있다는 의미다) 이러한 이유 때문에 타입스크립트에서는 특정값이 문자열과 숫자 두가지 타입을 가질 수 있는 상황이 발생하고 실제로 갖을 수 있다.
   2. 이런 상황이 발생하는데 이게 구조적 서브타이핑이다.

   ```tsx
   type stringOrNum = string | number;

   //구조적 서브타이핑 예시
   interface A {
     name: string;
   }

   interface B {
     name: string;
     age: number;
   }

   let a: A = { name: "Alice" };
   let b: B = { name: "Bob", age: 30 };

   a = b; // 가능
   b = a; // 불가능
   ```

- 덕타이핑? : 같은 속성을 가지면 같은 타입으로 간주, 메서드를 기준으로 타입판단(다른 객체라도 같은 메서드를 가지고 있다면 같은 타입으로 판단한다)
- 구조적 타이핑의 한계 : 만약 한가지의 객체가 단일타입이 아닌 다른 타입이 섞여있을 경우에 같은 타입이 섞여있는 경우 문제가 발생할 수 있다 예시코드로 설명하겠다

```tsx
interface triangle {
  firstAngle: number;
  secAngle: number;
  ThrAngle: number;
}
function sumAngle(angle: triangle) {
  //...합 구하는 함수
}

interface equiAngler {
  firstAngle: 60;
  secAngle: 60;
  ThrAngle: 60;
  name: "정삼각형";
}
sumAngle(equiAngler); //오류발생
```

1. 타입스크립트에서의 타입 선언 방법

   1. 앞서 말한것처럼 인터페이스를 통해서 사용도 가능하고
   2.

   ```tsx
   type Person = {
     name: string;
     age: number;
   };
   interface Person {
     name: string;
     age: number;
   }
   ```

   함수에서 구조 분해할당을 통해 매개변수에 어떤 타입이 들어오게 할지 예측이 가능하게한다

   ```tsx
   interface User {
     name: string;
     age: number;
   }

   function printUser({ name, age }: User) {
     console.log(`이름: ${name}, 나이: ${age}`);
   }

   const user: User = { name: "Bob", age: 25 };
   printUser(user); //이름: Bob, 나이: 25
   ```

   ### enum

   편의를 위해 이넘 이라고 부르겠다

   이넘은 클래스 처럼 타입 공간에서 타입을 제한하는 역할을 하지만 자바스크립트 런타임에서 실제 값으로 사용이 가능한데 이넘에 키오브 타입오브를 사용해서 다른 함수에 인자를 넘겨줄 수 있다.
   또한 이넘은 타입, 인터페이스와 다르게 값, 타입 모두 인식되는 특징을 가지고 있다.

   ### 타입 확인법

   클래스를 사용해서 변수를 만들 때 타입오브 함수를 사용했을 때 타입공간에서 의 타입은 new 키워드가 사용된 생성자 함수에서 값을 가져오기 때문에 클래스의 타입인 함수가 아닌 클래스명이 나오게된다

## 원시타입

우리가 알고있는기본적인 타입이다.

1. undefined : 만약 변수 선언만하고 값을 입력안했을 때 나옴
2. null : 타입스크립트에서는 널 값도 명시해줘야함
   null 값과 undefined 의 차이점 = ? : type ; 이랑 a : type | null; 이정도 차이가 있다 둘 다 직업이 있을 수 있고 없을 수 있다는 의미에 대해서는 같지만 언디파인드와 널값이 사용된다는 거에 대해서 차이가 있다 (코드 안정성에 대해서 널을 사용하는게 좋나요 언디파인드를 사용하는게 좋나요? 아님 널, 언디파인드는 어떤 상황에서 사용하는게 좋을지 궁금합니다! → 타입가드로 넘어가는 과정도 궁금합니다)
3. symbol : 어떤 값과도 중복되지 않는 유일한 값을 만들 수 있는 타입 심지어 같은 문자열을 넘겨준다고 해도 다른 값을 가지고 있다!

## 객체타입

원시타입에 속하지 않는 값은 모두 객체 타입이다 그로인해 매우 넓은 범주를 가지고 있다

1. object 타입 : 객체에 해당하는 모든 타입값을 유동적으로 할당할 수 있어 정적 타이핑 하는 의미가 없어짐
2. {} : 주로 괄호 내부의 객체의 타입을 지정하는 방식으로 사용함 하지만 객체가 중괄호 안에서 선언된 구조랑 일치해야함 + {} 타입으로 지정된 객체는 어떤 값도 속성으로 할당이 불가능함
3. array : 타입스크립트에서는 어레이를 별도의 타입으로 다룬다. [] 이렇게 선언하는건 마찬가지 자바스크립트랑 가장 큰 차이는 배열에 같은 타입의 값들만 들어가야 한다 정도 왜냐면 배열에 타입을 할당하기 때문에 다른 값이 할당되면 문제가 생기기 때문
4. type, interface : 실무에서 잘 안쓰이는 오브젝트 타입을 안쓰고 객체형 데이터를 정의하기 위해서 사용함
5. function(함수) : 타입스크립트에서는 파라미터 값도 타입을 지정해야한다 또한 화살표 함수를 정의할 때 함수 자체의 타입을 명시해줘야한다

```tsx
function add(x: number, y: number): number {
  return x + y;
}

//타입선언을 통한 함수정의
type MathOperation = (a: number, b: number) => number;

const multiply: MathOperation = (x, y) => x * y;

//인터페이스를 통한 함수정의
interface StringConverter {
  (input: string): string;
}

const toUpperCase: StringConverter = (text) => text.toUpperCase();
```
