# 02. 타입이란

## 타입의 기본 개념과 필요성

---

### 2.1.1 자료형으로서의 타입

> 타입이란?
>
> 변수에 저장할 수 있는 **값의 종류**를 나타내는 개념입니다.

### 기본 데이터 타입

- `undefined`
- `null`
- `boolean`
- `string`
- `symbol`
- `numeric` (number)
- `object`

### 타입이 필요한 이유

> 메모리 공간을 얼마나 차지할지 계산하기 위해 필요하며, 데이터를 해석할 때도 타입 체계를 기반으로 해석합니다.

---

### 2.1.2 집합으로서의 타입

타입은 단순히 자료형이 아니라, **값이 가질 수 있는 유효한 범위**라는 의미를 포함합니다.

- 타입이 지정된 값에는 **다른 타입의 값이 들어올 수 없습니다.**
- **타입 제한**을 통해 **호환되지 않는 인자 사용 시 에러를 발생**시키는 등의 검증을 수행합니다.

> 타입스크립트 컴파일러는 함수 호출 시 호환성 체크를 통해 오류를 사전에 방지합니다.

---

### 2.1.3 정적 타입과 동적 타입

| 구분          | 설명                               | 예시                |
| ------------- | ---------------------------------- | ------------------- |
| **정적 타입** | 컴파일 타임에 변수의 타입이 결정됨 | C, Java, TypeScript |
| **동적 타입** | 런타임에 변수 타입이 결정됨        | Python, JavaScript  |

### 용어 정리

- **컴파일 타임**: 소스코드를 **기계어로 변환**하는 시점
- **런타임**: 변환된 코드가 **실제로 실행되는 시점**

> 동적 타입 언어는 유연하지만, 예상치 못한 오류가 발생할 가능성이 더 큽니다.

---

### 2.1.4 강타입과 약타입

**타입 변환 방식**에 따라 다음과 같이 구분됩니다:

| 타입 분류                  | 설명                               | 예시 언어    |
| -------------------------- | ---------------------------------- | ------------ |
| **강타입 (Strong Typing)** | 암묵적인 타입 변환을 허용하지 않음 | Python, Java |
| **약타입 (Weak Typing)**   | 암묵적인 타입 변환을 허용          | JavaScript   |

> JavaScript는 약타입 언어로, 타입 변환에 의한 런타임 에러 발생 가능성이 있습니다.
>
> 따라서 **예방 코드 작성이 중요**합니다.

---

### 2.1.5 컴파일 방식

> 컴파일은 서로 다른 수준 간의 코드 변환입니다.

- **TypeScript는 자바스크립트로 변환되는 컴파일 언어입니다.**
- TypeScript의 목적은 사람이 읽기 쉬운 코드가 아니라, **런타임 오류를 컴파일 타임에 사전 검출**하는 것입니다.

### TypeScript의 독특한 특징

- **Java와 같은 언어는 자체적인 언어지만**, TypeScript는 자바스크립트에 **타입이라는 레이어**를 입힌 **확장 언어**입니다.
- 일종의 **템플릿 언어**로 보는 시각도 존재합니다.

---

## 타입스크립트의 타입 시스템과 유연성

---

### 2.2.1 타입 애너테이션 방식

타입 애너테이션은 변수, 상수, 함수의 인자 및 반환 값에 대해 **타입을 명시적으로 선언**하는 문법입니다.

이로 인해 어떤 타입의 값이 저장될지 **컴파일러에 직접 알려줄 수 있습니다**.

```tsx
let age: number = 25;
function greet(name: string): void {
  console.log("Hello " + name);
}
```

- 변수명 뒤에 `: 타입` 형식으로 선언
- 명시하지 않아도 동작하지만, **타입 추론이 어려워질 수 있음**

---

### 2.2.2 구조적 타이핑

타입스크립트는 **구조적 타입 시스템 (Structural Typing)** 을 따릅니다.

이는 변수나 객체의 **이름이 아닌 구조(속성)** 를 기준으로 타입을 구분합니다.

- Java나 C#처럼 **명목적 타이핑 (nominal typing)** 을 따르지 않음
- 같은 구조를 가지면 **다른 이름이어도 호환 가능**

---

### 2.2.3 구조적 서브타이핑

타입은 일종의 **집합**처럼 동작합니다.

→ 하나의 객체가 여러 타입에 속할 수 있음

```tsx
interface Pet {
  name: string;
}

let cat = { name: "Nabi", age: 3 };

function greet(pet: Pet) {
  console.log("Hello " + pet.name);
}

greet(cat); // 정상 동작
```

- `cat` 객체에는 `age`가 있지만, `name` 속성만 필요하므로 `Pet` 타입으로 간주됨
- 두 타입 간의 호환성은 오직 **타입의 내부 구조**로만 판단됨

---

### 2.2.4 자바스크립트를 닮은 타입스크립트

TypeScript는 JavaScript의 **덕 타이핑 (duck typing)** 방식을 계승하고 있습니다.

- 덕 타이핑: 객체가 특정 속성을 가지면 해당 타입으로 간주
- **명목적 타이핑**은 안전하지만 복잡도 증가
- 타입스크립트는 **유연성과 안정성**을 모두 고려한 방식

---

### 2.2.5 구조적 타이핑의 결과

구조적 타이핑은 유연하지만, 다음과 같은 오류도 발생할 수 있습니다:

```tsx
let c = { x: 1, y: 2 };
let axis = "z";

console.log(c[axis]); // 타입은 string | number
```

- `c` 객체는 `x`, `y`만 있으므로 `c["z"]`는 `undefined`
- 예상치 못한 `string` 결과가 발생할 수 있어 **런타임 에러 가능성**

---

### 2.2.6 타입스크립트의 점진적 타입 확인

**점진적 타입 확인 (Gradual Typing)** 은 다음을 의미합니다:

- 타입스크립트는 컴파일 타임에 타입을 확인
- 필요에 따라 **타입 선언 생략**도 가능
- 개발자는 점진적으로 타입을 추가해 코드의 안정성을 확보 가능

---

### 2.2.7 자바스크립트 슈퍼셋으로서의 타입스크립트

TypeScript는 **JavaScript의 상위 집합 (Superset)** 으로 설계되었습니다.

- 자바스크립트 코드도 유효한 타입스크립트 코드
- 타입 구문이 추가되는 순간부터 타입스크립트로 해석
- 런타임에서만 발생하던 에러를 **컴파일 타임에 사전 포착**

---

### 2.2.8 값 VS 타입

TypeScript에서 **값과 타입은 서로 다른 공간**에서 동작합니다.

- **값 공간**: 실행 시 존재하는 실제 데이터 (숫자, 문자열 등)
- **타입 공간**: 타입스크립트가 분석하는 메타 정보

```tsx
type Person = { name: string };
const person: Person = { name: "John" };
```

- `enum`, `class`는 **값과 타입 모두로 사용** 가능

---

### 2.2.9 타입을 확인하는 방법

TypeScript에서 타입을 확인하는 주요 방법은 다음과 같습니다:

### typeof

- 변수의 **기본 타입 확인**에 사용

```tsx
const v1 = typeof person;
```

### instanceof

- 객체가 **특정 클래스의 인스턴스인지 확인**
- **프로토타입 체이닝**을 기반으로 동작

```tsx
if (developer instanceof Developer) {
  // developer는 Developer 클래스의 인스턴스
}
```

### 타입 단언 (Type Assertion)

- 값의 타입을 **개발자가 강제 지정**
- `as` 키워드 사용

```tsx
let someValue: any = "hello";
let strLength: number = (someValue as string).length;
t;
```

---

## 원시 타입과 객체 타입

---

### 2.3 원시 타입 (Primitive Types)

자바스크립트 및 타입스크립트에서 가장 기본적인 데이터 유형입니다. **값 자체가 변경 불가능**하며, 참조가 아닌 값으로 저장됩니다.

| 타입          | 설명                                                        |
| ------------- | ----------------------------------------------------------- |
| **boolean**   | `true` 또는 `false` 값을 가짐                               |
| **undefined** | 값이 **정의되지 않음**을 의미                               |
| **null**      | **의도적으로 비어 있는 값**을 나타냄                        |
| **number**    | 모든 숫자 값 (정수, 실수 등)을 포함                         |
| **bigint**    | `2^53 - 1` 이상의 큰 정수를 표현 가능                       |
| **string**    | 문자열 값                                                   |
| **symbol**    | 고유하고 변경 불가능한 값. **객체 속성의 키**로 주로 사용됨 |

---

### 2.4 객체 타입 (Object Types)

객체 타입은 여러 속성을 가지는 복합적인 구조입니다. TypeScript는 객체를 세부적으로 타입 지정할 수 있게 해줍니다.

---

### 2.4.1 `object` 타입

- `object` 타입은 객체 전체를 포괄하는 유연한 타입입니다.
- 하지만 너무 유연해서 **정적 타이핑의 이점이 줄어들 수 있습니다.**
- 원시 타입은 포함되지 않음 (예: `string`, `number` 등은 `object` 아님)

---

### 2.4.2 `{}` 타입

- 객체 리터럴 형식의 타입 선언입니다.
- 객체의 **속성과 그 타입을 명확히 지정**할 수 있습니다.

```tsx
let user: { name: string; age: number } = {
  name: "Alice",
  age: 30,
};
```

---

### 2.4.3 배열 (Array)

TypeScript에서는 배열도 구체적으로 타입을 지정할 수 있습니다.

```tsx
let numbers: number[] = [1, 2, 3];
```

- 배열은 **단일 타입 값들로 구성**되어야 합니다.
- 이 점에서 자바스크립트보다 **엄격한 규칙**을 가집니다.

---

### 2.4.4 `type`과 `interface`

두 키워드 모두 **객체 타입을 정의**할 때 사용되며, 서로 유사한 역할을 수행합니다.

```tsx
type NoticePopupType = {
  title: string;
  description: string;
};

interface INoticePopup {
  title: string;
  description: string;
}

const noticePopup1: NoticePopupType = { title: "공지", description: "내용" };
const noticePopup2: INoticePopup = { title: "공지", description: "내용" };
```

- `type`: **유니언, 인터섹션 타입 등 더 다양한 조합**을 표현할 수 있음
- `interface`: **확장(extends)** 이 용이하며, 객체 설계에 자주 사용됨

---

### 2.4.5 함수 타입 (Function Type)

함수의 매개변수와 반환값에 대해 명시적으로 타입 지정이 가능합니다.

- **매개변수 타입**
- **반환 타입**
- **함수 전체 타입**

```tsx
// 함수 시그니처 타입
type Add = (a: number, b: number) => number;

const add: Add = (a, b) => a + b;
```

- 함수 전체의 타입을 명시할 때는 **화살표 함수 형태**의 시그니처를 사용합니다.
- 이를 통해 더 안전하고 예측 가능한 코드 작성이 가능합니다.

---
