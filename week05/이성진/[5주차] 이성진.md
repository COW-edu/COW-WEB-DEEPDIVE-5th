# 3주차 COW WEB-DEEP DIVE

## 1.  타입 확장

타입 확장은 기존 타입을 사용해서 새로운 타입을 정의하는 것을 의미한다. 기본적으로 TS에서는`interface`와 `type` 키워드를 사용해서 타입을 정의하고 `extend`, 교차 타입, 유니온 타입을 이용하여 타입을 확장한다.

### 타입 확장의 장점

- 타입 확장의 큰 장점은 코드 중복을 줄일 수 있다는 점이다. 중복되는 타입을 새롭게 선언하는 것보다 기존에 작성한 타입을 바탕으로 타입 확장을 함으로써 불필요한 코드 중복을 줄일 수 있다.

### 유니온, 교차 타입

- 저번주차에 배웠던 것처럼 유니온 타입과 교차 타입으로 타입 확장을 할 수있다.
    - 유니온 타입은 `or` 연산자를 사용하여 2개 이상의 타입을 조합하여 사용하는 방법이다. 합집합으로 이하하면 편하다.
    - 교차타입은 `and` 연산자를 사용하여 기존 타입을 합쳐 필요한 모든 기능을 가진 하나의 타입을 만드는 것으로 이해할 수 있다. 교집합으로 이해하면 편하다.

### extends와 교차타입 차이점

| 항목 | `extends` | `&` (교차 타입) |
| --- | --- | --- |
| 역할 | **상속(확장)** | **타입 병합** |
| 키워드 | 타입 제네릭에서 사용 | 타입 정의 시 사용 |
| 예시 | `T extends U` | `type A = B & C` |
| 유의점 | 제네릭 조건부 처리 가능 | 구조적 타입 병합 |

## 2. 타입 좁히기

TS에서 타입 좁히기는 변수 또는 표현식의 타입 범위를 더 작은 범위로 좁혀나가는 과정을 말하는데, 이 과정으로 더 정확하고 명시적인 타입 추론을 할 수 있게 되고, 복잡한 타입을 작은 범위로 축소하여 타입 안정성을 높일 수 있다.

### 타입가드에 따라 분기 처리하기

- TS에서 분기 처리는 조건문과 타입 가드를 사용하여 변수나 표현식의 타입 범위를 좁혀 다양한 상황에 따라 다른 동작을 수행하는 것을 말한다
- 타입 가드는 런타입에 조건문을 사용하여 타입을 검사하고 타입 범위를 좁혀주는 기능을 말한다.
- 자바스크립트 연산자를 활용한 타입 가드는 `typeof, instanceof, in`과 같은 연산자를 사용해서 제어문으로 특정 타입 값을 가질 수밖에 없는 상황을 유도하여 자연스럽게 타입을 좁히는 방식이다.

### typeof 연산자

- typeof 연산자를 활용해서 원시 타입에 대해 추론할 수 있다.
- `typeof`는 자바스트립트 타입 시스템만 대응할 수 있고 자바스크립트 동작 방식으로 인해 null과 배열 타입등이 object 타입으로 판별되는 등 복잡한 타입을 검증하는데에는 한계가 있다.
    - `typeof` 연산자를 사용하여 검사할 수 있는 타입 목록
        - `string`
        - `number`
        - `boolean`
        - `undefined`
        - `object`
        - `function`
        - `bigint`
        - `symbol`

### instanceof 연산자

- `typeof` 연산자가 주로 원시타입을 판별하는 데 사용한다면, `instanceof` 연산자는 인스턴스화된 객체 타입을 판별하는 타입 가드로 활용될 수 있다.
- `A instanceof B` 형태로 사용하며 A에는 타입을 검사할 대상 변수, B에는 특정 객체의 생성자가 들어간다.

### in 연산자

- in 연산자는 객체의 속성이 있는지 확인한 다음에 true 또는 false를 반환한다. in 연산자를 사용하면 속성이 있는지 없는지에 따라 객체 타입을 구분할 수 있다.
- 자바스크립트의 in 연산자는 런타임 값만을 검사하지만 TS에서는 객체타입에 속성이 존재하는지를 검사한다.

## 3. 조건부 타입

프로그래밍에서는 다양한 상활을 다루기 위해 조건문을 많이 사용하는데 타입도 마찬가지로 조건에 따라 다른 타입을 반환해야 할 때가 있다. 조건부 타입을 활용하면 중복되는 타입 코드를 제거하고 상황에 따라 적절한 타입을 얻을 수 있다.

### `extends`와 제네릭을 활용한 조건부 타입

- `extends` 키워드는 타입을 확장할 때 사용할 수도 있지만 타입을 조건부로 설정할 때 사용할 수 있다.
- 제네릭 타입에서는 한정자 역할로도 사용된다.
- 조건부 타입에서 `extends`를 사용할 땐 삼향 연산자 (?)와 함께쓴다.

### 조건부 타입을 사용하지 않았을 때의 문제점

- 조건부 타입을 사용하지 않는다면 타입이 명확하게 분리되지 않고 재사용이 어렵다
- 또한 같은 조건을 여러번 중복 작성해야 할 수도 있어서 코드의 가독성이 떨어질 수 있다.

### infer를 활용해서 타입 추론하기

- `infer` 키워드는 추론하다 라는 의미를 지니고 있는데 TS에서도 단어 의미처럼 타입을 추론하는 역할을 한다.
- 조건부 타입 안에서 타입을 임시로 추론하고 싶을 경우 `infer` 을 사용하면 된다

## 4. 커스텀 유틸리티 타입 활용하기

타입스크립트를 사용하다 보면 표현하기 힘든 타입을 마주할 때가 있다. 타입을 정확하게 설정해야만 해담 컴포넌트와 함수의 안정성과 사용성을 높일 수 있지만 타입스크립트에서 제공하는 유틸리티 타입만으로는 표현의 한계를 느낄 수 있다. 그럴 때는 커스텀 유틸리티 타입을 제작해서 사용한다.

### `styled-components`의 중복 타입 선언 피하기

- `styled-components`를 사용할 때 동일한 props 타입을 매번 선언해야 하는 불편함이 있는데 유틸리티 타입으로 공통 props를 정의해 타입 재사용성을 향상할 수 있다.
    
    ```tsx
    // 중복된 props 선언
    type ButtonProps = {
    primary?: boolean;
    size?: "small" | "medium" | "large";
    };
    const Button = styled.button<ButtonProps>  /* 스타일링 */;
    ```
    

```tsx
type StyledProps = {
primary?: boolean;
size?: "small" | "medium" | "large";
};
const Button = styled.button<StyledProps>; 
const LinkButton = styled.a<StyledProps>;
```

### `PickOne` 유틸리티 함수

- TS에서 서로 다른 2개 이상의 객체를 유니온 타입으로 받을 때 타입 검사가 제대로 진행되지 않을 때 `PickOne`이라는 이름의 유틸리티 함수를 구현하여 해결할 수 있다.

```tsx
type LoginOption =
| { email: string }
| { username: string }
| { phone: string };

// 또는 유틸리티 타입 사용 예시
type PickOne<T> = {
[K in keyof T]:
{ [P in K]: T[P] } &
{ [P in Exclude<keyof T, K>]?: never }
}[keyof T];

type LoginInput = PickOne<{
email: string;
username: string;
phone: string;
}>;
```

- 이렇게 한다면 `email`, `username`, `phone` 중 정확히 하나만 사용 가능하고 나머지 필드는 `never`로 제한하여 오류를 사전 방지할 수 있다.

## 5. `Record` 원시 타입 키 개선하기

객체 선언 시 키가 어떤 값인지 명확하지 않다면 `Record`의 키를 `string`이나 `number` 같은 원시 타입으로 명시하곤 한다. 이때 TS에서는 키가 유효하지 않더라고 타입상으로 문제 없기 때문에 오류를 표시하지 않는다. 이것은 예상치 못한 런타임 에러를 초래할 수 있다. 때문에 `Record`를 명시적으로 사용할 필요가 있다.

### 유닛 타입으로 변경하기

- 유닛 타입이란 단일 값만 허용하는 리터럴 타입이다
- 키가 유일한 집합이라면 다른 타입으로 쪼개지지 않고 오직 하나의 정확한 값을 가지는 타입을 사용할 수 있다.

### `Partial`을 활용하여 정확한 타입 표현하기

- 키가 무한한 상황에서는 `Partial`을 사용하여 해당 값이 `undefined`일 수 있는 상태임을 표현할 수 있다.
- 기존 타입을 변경하지 않고 유연한 타입 재사용이 가능하다.