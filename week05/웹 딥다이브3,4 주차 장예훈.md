# 웹 딥다이브3,4 주차

날짜: 2025년 4월 18일

# 타입확장

타입 확장은 코드를 작성하면서 계속 사용되는 코드의 반복을 줄일 수 있다는 장점이 있다.

투두를 만들 때 코드를 작성한다고 생각해보자

```tsx
interface todoItem {
	name : string;
	id : number;
	isComplete : boolean;
	}
	
//날짜 정보를 추가하고싶다
interface todoItem extends todoDate {
	date : string;
	}
//이렇게 추가하면 된다
```

이런식으로 인터페이스를 통해서 타입을 확장하여 반복적으로 작성되는 코드를 줄일 수 있다.

만약 인터페이스가 아닌 타입 키워드를 사용하고싶다면?

```tsx
type todoItem = {
	name : string;
	id : number;
	isComplete : boolean;
	};
	
type todoDate = {
date : string;
} & todoItem ;
```

이렇게 확장한 타입은 필요한 요소가 생길 때마다 필요한 타입을 만들 수 있고 기존에 있던 타입을 수정할 필요없이 확장된 타입만 수정하면 되기 때문에 편리하다고 볼 수 있다.

**유니온타입**

유니온 타입의 경우 앞서 학습했던 내용을 상기시켜보면 

A 타입이면서 B타입인 값이다. 이 타입은 A B 모두 가능하지만 이 둘 중 한가지인 것이고 두가지 타입의 요소를 전부 가지고 있다는 의미가 아니다. 즉 공통적으로 포함되는것만 사용이 가능하다는 것

이해하기 쉽게 설명하자면

```tsx
interface oreo {
	flavor : "쿠앤크";
	color : "검정";
	solid : boolean;
	}

interface milk{
	flavor : "고소";
	color : "흰색";
	liquid : boolean;
	}
	
function getDessert(food : oreo | milk){
	return food.liquid; // 오류발생
	return food.flavor; // 이러면 오류 안나요
}
```

이런식으로 디저트를 오레오를 먹을지 우유를 마실지 고르는 함수가 있다면 특정 타입에서만 사용되는 값은 유니온 타입으로 올 수 없다는 점이다.

결론적으로는 food는 오레오 또는 밀크 라는 타입에 해당하지 둘 다 되는건 아니다.

**교차타입**

기존 타입들을 한가지의 새로운 타입으로 정의하는 것 

A라는 타입의 집합이 있고 B라는 타입의 집합이 있는걸

C 라는 타입으로 새롭게 정의하는 것

```tsx
interface A {
	...
};

interface B {
	...
}
type C = A & B;
```

“유니온 타입과 같은거 아냐?” 라고 생각할 수 있겠지만 가장 큰 차이로는 이 새로운 타입으로 재정의 되면서 C라는 타입은 A, B 모든 것을 다 충족시키는 단일 타입이 된다. 기존의 getDessert 함수를 본다면 새롭게 정의된 타입이 모든 값의 요소들을 전부 가질 수 있게 된다.

이때 참고해야할 부분이 타입스크립트는 속성을 타입의 집합이 아닌 값의 집합으로 여기는데 이렇게 이해해야 모순적인 부분이 발생안한다

발생할 수 있는 모순은 “C타입은 A 타입과 B 타입의 교집합으로 볼 수 있기 때문에 그럼 공통된 속성이 없다면 그 집합은 존재할 수 없다고 볼 수 있지 않나?” 라는 부분인데 실제로 C라는 타입은 A, B 타입의 요소를 둘 다 가지고 있다. 이런 부분은 타입스크립트는 속성의 집합이 아닌 값의 집합을 갖는다 라는 개념을 생각하고 있다면 해결된다!

```tsx
type IdType = string | number;
type numeric = number | boolean;

type Universal = IdType & numeric;

typeof Universal
```

```tsx
type IdType = string | number;
type Numeric = number | boolean;

type Universal = IdType & Numeric;

let a : IdType = 1;
let b : Numeric = true;

let c : Universal = true; 
//Type 'boolean' is not assignable to type 'number'
let c1 : Universal = "hi";
//Type 'string' is not assignable to type 'number'.
let c2 : Universal = 123;

console.log(c); // true
console.log(c1); // "hi"
console.log(c2); // 123
```

이런식으로 결과는 잘 출력된다 하지만 위와 같은 오류가 발생하는데 본인은 이런 부분이 모순적으로 느껴져서 찾아봤다.

**지피티는 타입스크립트의 타입 시스템이 "값의 집합" 모델과 "구조적(subtyping) 모델"이 혼합된 언어이기 때문**입니다. 라고 말한다 

**원시타입의 경우**

```tsx
type A = number | string;
type B = number | boolean;
type C = A & B; // number
```

이 때 C의 경우 A라는 값과 B라는 값을 의 교집합이기 때문에 C는 number 값을 가질 수 있는거고

**객체타입의 경우**

```tsx
type A = { a: number };
type B = { b: string };
type C = A & B; // { a: number, b: string }
```

객체타입은 타입스크립트가 구조적 타이핑을 사용하기 때문에 c라는 타입은 결국 A와 B의 구조를 모두 만족시켜야 하기 때문에 두가지 속성을 모두 갖는 형태의 타입으로 정의된다.

**교집합이 없는 경우?!**

```tsx
type A = { a: number };
type B = { a: string };
type C = A & B;

const exam : C = {a : 123};
//Type 'number' is not assignable to type 'never'. 
// 이런 에러가 발생한다

```

a 라는 값은 넘버임과 동시에 스트링 타입일 수 없어 C라는 타입은 타입 충돌로 인해서 네버타입을 반환하게 된다.\

**익스텐드와 교차타입**

교차타입과 유니온 타입을 사용하여 새로운 타입을 정의할 땐 interface 는 사용이 불가능하고 type 키워드만 사용이 가능함 이 또한 구조적 타이핑의 영향이다. 

결론적으로는 타입키워드를 사용해서 새로운 타입이 추가될 경우 즉시적으로 오류는 발생하지 않지만 속성이 같은 이름을 갖는다면 never타입으로 할당돼 다른 타입을 지정할 수 없다.

**타입 확장의 방식**

```tsx
//책에서의 예시코드

interface Menu {
    name : string;
    image : string;
};

interface SpecialMenu extends Menu {
    gif : string;
}

interface PackageMenu extends Menu{
    text : string;
};

const menuList : Menu[] = [
    { name : "찜", image : "찜.png"},
    { name : "찌개", image : "찌개.png"},
    { name : "회", image : "회.png"},
];

const specialMenuList : SpecialMenu[] = [
    { name : "돈까스", image : "돈까스.png", gif : "돈까스.gif"},
    { name : "피자", image : "피자.png", gif : "피자.gif"},
]

const packageMenuList : PackageMenu[] = [
    { name : "1인분", image : "1인분.png", text : "1인 가구 맞춤형"},
    { name : "족발", image : "족발.png", text : "오늘은 족발로 결정"},
];

specialMenuList.map((menu) => menu.text);
//위 맵 함수는 스페셜메뉴에는 정의되지않은 속성을 가져오길 원하기 떄문에 오류가 발생한다.
```

당연한 소리일지 몰라도 연장된 타입에는 해당 타입의 속성이 있는 타입을 연결해줘야 오류가 발생안한다

# 타입 좁히기(타입가드)

타입을 좁혀 나가는 과정을 통해 더 정확하고 명시적인 타입 추론을 하고 타입 안정성을 더 높힐 수 있다. 

조건문, 타입 가드를 통해서 타입범위를 좁혀 다양한 상황에 따라 다른 동작을 수행하는 것을 타입스크립트 에서의 분기 처리 라고 한다.

타입스크립트에서는 컴파일 하면서 타입정보가 모두 제거되어 런타입에 존재하지 않아 조건문으로 타입을 구분이 불가능하다.

이래서 사용하는게 타입가드이다.

**타입가드의 종류**

1. JS 연산자를 사용한 타입가드
2. 사용자 정의 타입가드

1. 의 경우 typeof, instanceof, in 등의 키워드를 사용하여 특정 타입을 가지도록 유도한다.

2. 의 경우 사용자가 직접 어떤 타입으로 값을 좁힐지 지정

**원시타입 추론**

대표적으로 typeof 키워드사용

코드로 살펴보기

```tsx

function handleInput(input: string | number | boolean) {
  if (typeof input === "string") {
    console.log("문자열이다.");
  } else if (typeof input === "number") {
    console.log("숫자열이다.");
  } else if (typeof input === "boolean") {
    console.log("불린값이다.");
  }
}
```

이런식으로 함수 내부에 typeof 키워드를 사용해서 특정 타입을 한정하거나 좁히는 코드를 작성할 수 있다.

**instanceof 키워드**

책에 나와있는 코드를 설명하면서 이해한 내용을 풀어보겠다

```tsx
interface Range{
    start : Date;
    end : Date;
}

interface DatePickerProps {
    selectedDates? : Date | Range;
}

const DatePicker = ({selectedDates} : DatePickerProps) => {
    const [selected, setSelected] = useState(convertToRange(selectedDates));
} 

export function convertToRange (selected? : Date | Range) : Range | undefined {
  return selected instanceof Date ? {start: selected, end : selected} : selected;
}
```

**Range, DatePickerProps 라는 타입 정의** 

**DatePicker 함수 = selectedDates 라는 프롭스를 받는데 그 프롭스를 DatePickerProps 타입으로 고정됨**

**convertToRange 함수는 DatePicker 함수에서 받은 DatePickerProps 데이터 중 Date, Range 데이터가 다 오거나 값이 없을 수 있고 Range 일 경우 시작과 끝 데이터를 둘 다 받는지 확인 하나만 있음 똑같이 지정 없으면 언디파인디드 반환**

이렇게 이해했습니다.

**in 키워드**

in 키워드는  key in obj 라는 속성으로 사용되고 접근이 가능하면(B라는 객체에 A가 있으면) true 불가능하면 false를 반환한다.

```tsx

function MyComponent : React.FC<NoticeDialogProps> = (props) => {
  if (hasCookieKey(props)) {
    return <div>{props.cookieKey}</div>; 
  };
  return <div>{props.다른속성}쿠키 없음</div>;
};
```

책에 있는코드가 잘 이해가 안가 다시 풀어서 써봤다.

**“얼리리턴 : 특정조건에 부합하지 않을 경우 바로 반환 하는 것”**

**is 연산자로 사용자 정의 타입 가드 만들기**

**“타입명제 : 함수의 반환 타입에  대한 타입 가드를 수행하기 위해 사용되는 특별한 형태의 함수”**

여기서 불린값을 쓰는 경우랑 is연산자를 쓸 때 큰 차이점은 타입스크립트가 인식을 할 수 있는지 없는지 차이이다.

```tsx
function 함수명(변수: 어떤타입): 변수 is 좁혀질타입 {
  return 타입확인조건;
}

//예시코드
const isString = (str : string) srt is string  => {
	nameList.includes(str);
```

이런 모양으로 사용되고 유니언 타입이 사용되거나 하나의 타입값이 아닌 여러가지 타입의 집합이 있을 때 거기서 어떤 타입이 들어올지 좁혀주는 역할을 할 수 있게 된다.

**식별가능한 유니온**

여러가지 공통된 속성을 가지고 있는 타입이 있을 때 하나의 집합으로 모이면 의도하지 않게 타입에러가 발생할 수 있기 때문에 사용된다

```tsx
type Dog = { name: string; sound: "bark" };
type Cat = { name: string; sound: "meow" };
type Animal = Dog | Cat;

function makeSound(animal: Animal) {
  console.log(animal.sound);
}
```

이 때 어떤 동물이 소리를 내는지 알 수 없음

```tsx
type Dog = { kind: "dog"; name: string; sound: "bark" };
type Cat = { kind: "cat"; name: string; sound: "meow" };
type Animal = Dog | Cat;

function makeSound(animal: Animal) {
  if (animal.kind === "dog") {
    console.log(`${animal.name} says ${animal.sound}`);
  } else {
    console.log(`${animal.name} says ${animal.sound}`);
  }
}
```

이렇게 kind라는 속성을 추가함으로 어떤 동물인지 구분 할 수 있음 이러한 개념이다

중요한거는 각 값마다 중복되지 않는 고유값을 사용해야한다.

만약 kind가 똑같이 포유류 라는 값이면 속성자체는 늘어나도 구분을 못하기 때문에 없느니만 못하다.

이렇게 구분되는 고유값을 “유닛 타입” 이라고 한다.

**Exhaustiveness Checking**

지금까지 설명한 타입 가드들은 특정 부분만 좁혀 해당 요구에 대한 요청만 들어주는 느낌이었다면 지금 설명하는 것은 모든 타입에 대해서 값을 확인, 평가하여 안정성을 확보하는 방법이다.

```tsx
const exhaustiveCheck = (param : never) => {
	throw new Error("type error");
	};
```

이런식으로 많이 사용되고 값이 들어올 수 없는 네버 타입을 지정 후 만약 파라미터 값으로 들어온다면 에러를 띄우는 함수이다

# 조건부 타입

쉽게 말하면 삼향연산자를 타입에도 적용하겠다는 의미이다.

예를 들어 어떤 타입을 확장하고 싶은데 그 타입이 할당가능하면 해당 타입으로 불가능 하다면 다른 타입으로 하겠다는 것이다.

```tsx
type MyType<T> = T extends string ? string[] : number[];

let a: MyType<string>; 
let b: MyType<number>; 
```

예시코드로 살펴보자면 스트링이 가능하면 앞에 타입을 불가능하면 뒤에 타입을 쓰겠다는 의미이다.

```tsx
type Korean = { language: "Korean"; greeting: "안녕하세요" };
type English = { language: "English"; greeting: "hi" };

type DetectResult<T extends "안녕하세요" | "hi"> =
  T extends "안녕하세요" ? Korean : English;

function detectLanguage<T extends "안녕하세요" | "hi">(input: T): DetectResult<T> {
  if (input === "안녕하세요") {
    return { language: "Korean", greeting: "안녕하세요" } as DetectResult<T>;
  } else {
    return { language: "English", greeting: "hi" } as DetectResult<T>;
  }
}

detectLanguage("안녕하세요"); // 이때 타입은 코리안이 되고
detectLanguage("hi"); // 이때 타입은 잉글리시가 됨
```

이런식으로 함수 파라미터에 어떤 값이 들어오는지에 따라서 타입이 변경되고 어떤 타입이 들어오는지 유추가가능하다.

**infer 을 이용한 타입추론**

infer 란 조건부 타입을 정의할 때, 주어진 타입으로부터 어떤 값을 추론하거나 타입을 추출할때 사용하는 키워드이다.

앞서 작성한 예시코드를 기반으로 infer를 사용해서 타입 추론 함수를 만들어보자

```tsx
type Korean = { language: "Korean"; greeting: "안녕하세요" };
type English = { language: "English"; greeting: "hi" };
type Spanish = { language: "Spanish"; greeting: "hola" };
type French = { language: "French"; greeting: "bonjour" };

type DetectResult<T> = T extends infer U
  ? U extends "안녕하세요"
    ? Korean
    : U extends "hi"
    ? English
    : U extends "hola"
    ? Spanish
    : U extends "bonjour"
    ? French
    : never
  : never;

function detectLanguage<T extends "안녕하세요" | "hi" | "hola" | "bonjour">(input: T): DetectResult<T> {
  if (input === "안녕하세요") {
    return { language: "Korean", greeting: "안녕하세요" } as DetectResult<T>;
  } else if (input === "hi") {
    return { language: "English", greeting: "hi" } as DetectResult<T>;
  } else if (input === "hola") {
    return { language: "Spanish", greeting: "hola" } as DetectResult<T>;
  } else if (input === "bonjour") {
    return { language: "French", greeting: "bonjour" } as DetectResult<T>;
  } else {
    throw new Error("Unsupported greeting");
  }
}

const result1 = detectLanguage("안녕하세요"); // 타입: Korean
const result2 = detectLanguage("hi");        // 타입: English
const result3 = detectLanguage("hola");      // 타입: Spanish
const result4 = detectLanguage("bonjour");   // 타입: French

```

이 코드에서는 인퍼인 U가 어떤 타입이 올지 추측하고 있다 입력값에 따라서 타입을 추측한다.

**템플릿 리터럴 타입**

간단한 개념이다 자바스크립트의 템플릿 리터럴 개념은 `${value}` 를 사용하여 특정 문자열 특정 페이지에 타입을 선언하는 방법이다.

**PickOne 함수**

타입스크립트에서 서로 다른 2개 이상의 객체를 유니온 타입으로 받을 때 타입 검사가 잘 안이루어져 검사가 진행이 안되는 이슈가 있다 이 문제를 해결하기 위해서 **PickOne 이라는 함수를 사용한다.**

기존에 서로다른 속성의 타입을 입력했을 때 모두 잘 출력되는 현상때문에 사용하게 됐고 각 타입 객체마다 구분이 가능한 기준의 속성을 만들어 이런 합집합의 타입이 출력되는 현상을 막아준다. 하지만 계속 타입을 넣어야한다면 번거롭고 휴먼에러가 발생할 가능성도 높아 **PickOne 함수를 사용하게 됐다.**

책에서는 픽원 이라는 키워드를 사용하여 두가지 타입 객체 중 한가지만 반환 할 수 있게한다.

**NonNullable 함수**

never 타입을 활용해서 널값 또는 언디파인디드를 반환하면 never 타입으로 에러를 반환 그렇지 않다면 제네릭 타입 즉 타입 가드를 반환해서 훠얼씬 안정적으로 타입을 지킬 수 있다.

**Record 원시 타입 키 개선**

유효한 키가 아니더라도 타입상으로 문제가 없기 때문에 요류를 표기 하지는 않지만 이는 예상하지 못한 에러를 야기할 가능성이 있기 때문에 Record를 명시하여 사용한다.

```tsx
type Category = string;
interface food {
	name : string;
	//....
	}
const foodByCategory : Record<Category, food[]> = { 
	"한식" :[{name : "불고기"}, {name : "비빔밥"},...],
	"일식" :[{name : "스시"}, {name : "스키야키"},...],
	}
	
	foodByCategory["양식"].map((food) => console.log(food.name));
	//실행 전 까지는 에러 발생 x 하지만 실행 후 에러 발생
	foodByCategory["양식"]?.map((food) => console.log(food.name));
	//이렇게 옵셔널 체이닝을 쓴다면 에러를 일으키지 않고
	//양식이라는 값이 있다면 그대로 실행하여 결과를 반환
	//그렇지 않다면 언디파인디드 반환
	
```

1. 유닛타입으로 변경하기
    1. 만약 키가 유한한 집합이라면 하나의 정화관 값을 가지는 타입으로 사용가능함  type Category = “한식” | “양식”; 이런식으로 타입을 정의하면 됨
2. 정확한 타입 표현하기
    1. 키가 유한하지 않다면 Partial을 사용하여 언디파인디드 일 수 있다는 것을 표현 가능하고 표현 해줘야함 
    2. 예시코드
    
    ```tsx
    type MyPartialRecord<K extends string, T> = Partial<Record<K, T>>;
    
    type Category = string;
    
    interface Food {
      name: string;
    }
    
    const foodByCategory: MyPartialRecord<Category, Food[]> = {
      한식: [{ name: "불고기" }, { name: "비빔밥" }],
      일식: [{ name: "스시" }, { name: "스키야키" }],
    };
    근데 여기서 저렇게 파티얼을 쓰면그냥 
    foodByCategory["양식"].map((food) => console.log(food.name)); 이렇게 써도 에러가 안난다는거잖아?
    ```
    

파티얼을 쓰면 키를 선택적으로 존재한다는 의미가 되어 값이 존재하지 않더라도 오류를 발생시키지 않고 언디파인디드를 반환한다.