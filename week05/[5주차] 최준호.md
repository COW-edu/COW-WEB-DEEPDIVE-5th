# 타입 확장하기, 좁히기, 활용하기

## 타입 확장하기

### 타입 확장의 장점

- 중복된 코드 제거
- 명시적인 코드작성
- 확장성

```tsx
// interface의 타입 확장
interface Item {
  key: string;
  name: string;
  price: number;
}

interface CartItem extends Item {
  amount: number;
}

//type의 타입확장
type Item = {
  key: string;
  name: string;
  price: number;
};

type CartItem = {
  amount: number;
} & Item;
```

### 유니온 타입 & 교차타입

```tsx
// 유니온타입
type UnionType = A | B;
// 교차타입
type IntersectionType = A & B;
```

유니온 타입 → 합집합의 개념. 유니온 타입으로 선언된 값은 유니온 타입에 포함된 모든 타입이 공통으로 갖고 있는 속성에만 접근할 수 있다. ⇒ UnionType은 A 또는 B 타입에 해당이 되지만 A이면서 B인 것은 아니다.

교차타입 → 교집합의 개념. 교차 타입으로 선언된 값은 모든 속성을 가진 단일 타입이 된다. ⇒ IntersectionType은 A타입이자 B의 타입이다.

## 타입가드

- 타입 가드 ⇒ 런타임에 조건문을 사용하여 타입을 검사하고 타입 범위를 좁혀주는 기능을 말한다.
- 분기 처리 ⇒ 조건문과 타입 가드를 활용하여 변수나 표현식의 타입 범위를 좁혀 다양한 상황에 따라 다른 동작을 수행하는 것을 말한다.
- 타입을 구분하여 로직 처리시 `if`문 과같은 경우 타입의 정보가 런타임에서 제거되기에 조건이 만들어지지 않음 ⇒ 타입 가드를 통해 해결한다.

### typeof 연산자 활용하기

- `typeof` → 원시 타입을 좁히는 용도로 사용
  - string / number / boolean / undefined / object / function / bigint / symbole

```tsx
const exampleFunction: (date: string| Date) => string | Date = (date) => {
	if(typeof date === "string") {
		return ...
	}

	return ...
}
```

### instanceof 연산자 활용하기

- `instanceof` → 인스턴스화된 객체 타입을 판별하는 타입 가드로 사용 가능.
- `A instanceof B` → A: 타입을 검사할 대상 변수 / B: 특정 객체의 생성자

```tsx
type Range = {
  start: Date;
  end: Date;
};

function exampleFunction(selectedDate?: Date | Range): Range | undefined {
  return selectedDate instanceof Date
    ? { start: selectedDate, end: selectedDate }
    : selectedDate;
}
```

### in 연산자 활용하기

- 속성이 있는지 없는지에 따라 객체 타입을 구분
- `A in B` 형태로 사용. A라는 속성이 B객체에 존재하는지를 검사하고 접근할 수 있으면 true 반환

```tsx
interface SuccessResponse {
  status: "ok";
  data: string[];
}

interface ErrorResponse {
  status: "error";
  message: string;
}

type ResponseProps = SuccessResponse | ErrorReseponse;

function handleResponse(res: ResponseProps) {
  if ("data" in res) {
    console.log(res.data[0]);
  } else {
    console.log(res.message);
  }
}
```

### is 연산자 활용하기

- is 연산자를 통해 직접 사용자 정의 타입 가드를 만들 수 있음
- 런타임 로직 만들기 및 조건 통과시 컴파일러가 타입을 자동으로 좁혀줌.

```tsx
const destinationCodes = ["ICN", "JFK", "HND", "LHR"] as const;
type DestinationCode = (typeof destinationCodes)[number];

function isDestinationCode(x: string): x is DestinationCode {
  return (destinationCodes as readonly string[]).includes(x);
}
```

- `x`의 string이 DestinationCode로 추론할 수 있게 한다.

## 타입좁히기 - 유니온

- TypeScript는 구조적 타입 시스템을 사용하고 있음 → 모든 필드가 호환되면 같은 타입으로 생각함.
- 잘못된 객체가 들어가도 필요한 객체 속성이 들어가있으면 타입스크립트 컴파일러는 해당 부분을 알아낼 수 없다.

```tsx
type TextError = {
  errorCode: string;
  errorMessage: string;
};

type ToastError = {
  errorCode: string;
  errorMessage: string;
  toastShowDuration: number;
};

type AlertError = {
  errorCode: string;
  errorMessage: string;
  onConfirm: () => void;
};

type ErrorFeedbackType = TextError | ToastError | AlertError;

const errorArr: ErrorFeedbackType[] = [
  ...{
    errorCode: "999",
    errorMessage: "잘못된 에러",
    toastShowDuration: 3000,
    onConfirm: () => {},
  },
]; // 위 코드에서 해당 객체는 에러가 나오는 코드이지만, 타입 에러가 나오지 않음. 문제 발생 여지ㅇㅇ
```

- 식별할 수 있는 유니온이란 타입 간의 구조호환을 막기 위해 타입마다 구분할 수 있는 판별자를 달아 포함 관계를 제거해야함.
- 아래 코드에서 errorType을 `"TEXT"  | "TOAST" | "ALERT"` 라는 문자열 리터럴 값으로 고정되기에 해당 부분의 에러를 컴파일러가 잡아낼 수 있다.

```tsx
type TextError = {
  errorType: "TEXT";
  errorCode: string;
  errorMessage: string;
};

type ToastError = {
  errorType: "TOAST";
  errorCode: string;
  errorMessage: string;
  toastShowDuration: number;
};

type AlertError = {
  errorType: "ALERT";
  errorCode: string;
  errorMessage: string;
  onConfirm: () => void;
};

type ErrorFeedbackType = TextError | ToastError | AlertError;

const errorArr: ErrorFeedbackType[] = [
  ...{
    errorType: "TEXT",
    errorCode: "999",
    errorMessage: "잘못된 에러",
    toastShowDuration: 3000, //toastShowDuration does not exist in type TextError
    onConfirm: () => {}, //onConfirm does not exist in type TextError
  },
];
```

### 주의점

- 식별할 수 있는 유니온의 판별자는 유닛 타입(하나의 정확한 값을 가지는 타입, 다른타입으로 쪼개지지 않음)을 의미한다.

```tsx
interface a {
  value: "a";
  answer: number;
} //o
interface b {
  value: string;
  answer: number;
} //x <- value가 unit type이 아니기에 판별자가 아님.
interface c {
  value: Error;
  answer: number;
} //x <- value가 쪼개질 수 있는 타입이기에 판별자가 아님.
```

## Exhaustiveness Checking으로 정확한 타입 분기 유지하기

- `Exhaustiveness Checking`은 모든 케이스에 대해 철저하게 타입을 검사하는 것을 말한다.
- 모든 케이스에 대한 타입 분기 처리를 해주지 않았을 때, 컴파일타임 에러가 발생하는 것을 `Exhaustiveness Checking`이라 한다.

```tsx
type ProductPrice = "10000" | "20000" | "5000";

const getProductName = (productPrice: ProductPrice):string => {
	if(productPrice === "10000") ...
	if(productPrice === "20000") ...
	else {
		exhaustiveCheck(productPrice);
//Error: Argument of type 'string' is not assignable to parameter of type "never"
		...
	}
};

const exhaustiveCheck = (param: never) => {
	throw new Error("type Error");
};
```

- exhaustiveCheck 함수의 `param: never` 를 통해 매개변수로 어떤 값도 들어올 수 없게한다. 그렇기에 else문에 사용시 앞 조건에서 모든 타입에 대한 분기 처리를 강제할 수 있다.

---

## 조건부타입

### extends와 제네릭을 활용한 조건부 타입

- `extends` : 타입 확장 및 타입을 조건부로 설정할 때 사용.
- 조건부 타입으로 사용하는 extends ⇒ `T extends U ? X : Y`

```tsx
interface Bank {
  financialCode: string;
  companyName: string;
  name: string;
  fullName: string;
}

interface Card {
  financialCode: string;
  companyName: string;
  name: string;
  appCardType: string;
}
type PayMethod<T> = T extends "card" ? Card : Bank;
type CardPayMethodType = PayMethod<"card">; // Type: Card
type BankPayMethodType = PayMethod<"bank">; // Type: Bank
```

### 조건부 타입을 사용하지 않았을 때의 문제점

```tsx
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>;
export const useGetRegisteredList = (
  type: "card" | "appcard" | "bank"
): UseQueryResult<PayMethodType[]> => {
  const url = `~~~/${type === "appcard" ? "card" : type}`;
  const fetcher = fetcherFactory<PayMethodType[]>({
    onSuccess: (res) => {
      const usablePocketList =
        res?.filter(
          (pocket: PocketInfo<Card> | PocketInfo<Bank>) =>
            pocket?.useType === "USE"
        ) ?? [];
      return usablePocketList;
    },
  });

  const result = useCommonQuery<PayMethodType[]>(url, undefined, fetcher);
  return result;
};
```

- PayMethodType[]에서 해당 PayMethodType이 PayMethodInfo<Card>인지, PayMethodInfo<Bank>인지 정확히 구분하지 못함.
- 해당 함수는 인자로 넣는 타입에 알맞은 타입을 반환하지 못함.

### extends조건부 타입을 활용하여 개선하기

```tsx
type PayMethodType<T extends "card" | "appcard" | "bank"> = T extends
  | "card"
  | "appcard"
  ? Card
  : Bank;

export const useGetRegisteredList = <T extends "card" | "appcard" | "bank">(
  type: T
): UseQueryResult<PayMethodType<T>[]> => {
  const url = `~~~/${type === "appcard" ? "card" : type}`;
  const fetcher = fetcherFactory<PayMethodType<T>[]>({
    onSuccess: (res) => {
      const usablePocketList =
        res?.filter(
          (pocket: PocketInfo<Card> | PocketInfo<Bank>) =>
            pocket?.useType === "USE"
        ) ?? [];
      return usablePocketList;
    },
  });

  const result = useCommonQuery<PayMethodType<T>[]>(url, undefined, fetcher);
  return result;
};
```

- 제네릭으로 받은 값이 “card” 또는 “appcard”이면 PocketInfo<Card>, “bank”이면 PocketInfo<Bank>를 반환한다.
- 불필요한 타입 가드와 불필요한 타입 단언을 하지 않고 해결할 수 있다.

### infer를 활용하여 타입 추론하기

- `infer`는 타입을 추론하는 역할을 한다.
- 삼항 연산자를 사용한 조건문의 형태를 가진다.
- extends로 조건을 서술하고 infer로 타입을 추론한다.

```tsx
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;

const promises = [Promise.resolve("Mark"), Promise.resolve(38)];
type Expected = UnpackPromise<typeof promises>; // string | number
```

- 위 코드에서 promises는 Promise의 반환값이 string(’Mark’)과 number(38)일 것임.
- `T extends Promise<infer K>[] ? K : any`를 통해 Promise의 반환값으로 해당 타입이 결정될 것을 이야기함.
- promises에서는 string과 number가 반환값이 될 것이고 `UnpackPromise<typeof promises>`에 의해 Expected는 string | number가 된다.

<aside>

`A extends B ? X : Y` 안에서 infer를 통해 B의 일부를 K라는 이름으로 빼서 이를 X나 Y에서 활용한다.

</aside>

## 템플릿 리터럴 타입 활용하기

- 유니온 타입을 사용하여 변수 타입을 특정 문자열로 지정할 수 있다.
- 템플릿 리터럴 타입은 JS의 템플릿 리터럴 문법을 사용해 특정 문자열에 대한 타입을 선언할 수 있는 기능이다.

```tsx
type Vertical = "top" | "bottom";
type Horizon = "left" | "right";

type Direction = Vertical | `${Vertical}${Capitalize<Horizon>}`;
// Capitalize -> 리터럴 타입 T의 첫 글자를 대문자로 바꿔줌.
// "top" | "bottom" | "topLeft" | "topRight" | "bottomLeft" | "bottomRight"
```

## 커스텀 유틸리티 타입

- Pick, Omit같은 유틸리티 타입을 활용하여 필요한 부분만 선택하여 설정할 수 있음.

```tsx
type StyledProps = Pick<Props, "height" | "color" | "isFull">;
// props에서 'height, 'color', 'isFull'속성만 가져올것임.
```

### PickOne 유틸리티 함수

- 식별할 수 있는 유니온으로 객체를 구분할 수 있으나 일일이 식별자를 지정해야하는 불편함이 생김.
- 하나의 속성이 들어왔을 때 다른 타입을 옵셔널한 Undefined 값으로 지정하는 방법을 통해 해결

```tsx
type PickOne<T> = {
  [P in keyof T]: Record<P, T[P]> &
    Partial<Record<Exclude<keyof T, P>, undefined>>;
}[keyof T];

//해체하기
//1. One
type One<T> = { [P in keyof T]: Record<P, T[P]> }[keyof T];
// 하나의 속성 P를 보존하고 타입은 T[P]를 유지함.

//2. ExcludeOne<T>
type ExcludeOne<T> = {
  [P in keyof T]: Partial<Record<Exclude<keyof T, P>, undefined>>;
}[keyof T];
// 선택된 키 P를 제외한 나머지 키 집합.
// Exclude<keyof T,P> <- P를 제외한 나머지 키 집합
// Partial<Record<Exclude<...>,undefined>> <- 옵셔널타입인데 값은 Undefined임.

//3. 합치기
type PickOne<T> = One<T> & ExcludeOne<T>;
```

### NonNullable 타입 검사 함수를 사용하여 타입 가드하기.

- NonNullable → null이나 undefined가 아닌 경우를 제외할 수 있다.

```tsx
// TS 유틸리티 타입인 NonNullable, null이나 undefined가 아닌 경우를 제외할 수 있다.
type NonNullable<T> = T extends null | undefined ? never : T;

//NonNullable 유틸리티 타입을 사용한 타입 가드 함수.
//value가 null이나 undefined이면 false를 반환함.
function NonNullable<T>(value: T): value is NonNullable<T> {
  return value !== null && value !== undefined;
}
```

```tsx
const shopList = [
  { shopNo: 100, category: "chicken" },
  { shopNo: 101, category: "pizza" },
  { shopNo: 102, category: "noodle" },
];

class AdCampaignAPI {
  static async operating(shopNo: number): Promise<AdCampaign[]> {
    try {
      return await fetch(`/ad/shopNumber=${shopNo}`);
    } catch (error) {
      return null;
    }
  }
}

const shopAdCampaignList = await Promise.all(
  shopList.map((shop) => AdCampaignAPI.operating(shop.shopNo))
);
```

- 위 코드에서 `shopAdCampaignList`는 Array<AdCampaign[] | null>로 추론된다.
- null로 추론되기에 이를 사용할 때 타입 가드를 반복해서 사용해야한다. → 필터링을 통한 문제 해결시 null이 나오지 않음 ⇒ `NonNullable`사용.

```tsx
const shopList = [
  { shopNo: 100, category: "chicken" },
  { shopNo: 101, category: "pizza" },
  { shopNo: 102, category: "noodle" },
];

const shopAdCampaignList = await Promise.all(
  shopList.map((shop) => AdCampaignAPI.operating(shop.shopNo))
);

const shopAds = shopAdCampaignList.filter(NonNullable);
// 추론시 Array<AdCampaign[]>으로 추론된다.
```

## 불변 객체 타입으로 활용하기

- `as const` 키워드로 객체를 불변 객체로 선언하고, `keyof` 연산자를 사용하여 실제 객체에 존재하는 키값만 받을 수 있도록 설정할 수 있다.
- `keyof, as const`로 객체 타입을 구체적으로 설정하면 타입에 맞지 않는 값을 전달할 경우 타입 에러가 반환되기 때문에 컴파일 단계에서 발생할 수 있는 실수를 방지할 수 있다.

```tsx
const colors = {
  red: "#F45452",
  green: "#0C952A",
  blue: "#1A7CFF",
};

const getColorHex = (key: string) => colors[key];
```

- 위 코드에서 getColorHex의 반환 값은 any가 된다. → key가 정해진 것이 아닌 string이기 때문에 colors에 어떤 값이 추가될지 몰라 반환값이 any가 된다.

```tsx
const colors = {
  red: "#F45452",
  green: "#0C952A",
  blue: "#1A7CFF",
} as const;

const getColorHex = (key: keyof typeof colors) => colors[key];
```

- as const를 통해 colors 객체를 불변 객체로 선언
- keyof 연산자를 통해 colors 객체에 존재하는 키 값만 받도록 설정한다.

## Record 원시 타입 키 개선하기

- `Record` → 객체에 없는 키 값을 사용하더라도 TS는 오류를 표기하지 않는다.

```tsx
type Category = string;
interface Food {
  name: string;
  ...
}
const foodByCategory: Record<Category, Food[]> = {
  한식: [{ name: "제육덮밥" }, { name: "뚝배기 불고기" }],
  일식: [{ name: "초밥" }, { name: "텐동" }],
};

console.log(foodByCategory["양식"]); // undefined
foodByCategory["양식"].map((food) => console.log(food.name)); //런타임에 에러발생함.
```

- JS 옵셔널 체이닝 등을 사용해 런타임 에러를 방지할 수 있음.

```tsx
foodByCategory["양식"]?.map((food) => console.log(food.name));
```

- 옵셔널체이닝을 써야하는 부분을 착각하면 예상치 못한 런타임에러가 발생한다.

### 유닛 타입으로 변경하기

- 키가 유한한 집합이면 유닛 타입을 사용할 수 있음.

```tsx
type Category = '한식' | '일식'
...
console.log(foodByCategory["양식"]);
// Property "양식" does not exist on type 'Record<Category, Food[]>'
```

### Partial을 활용하여 정확한 타입 표현하기.

- 키가 무한한 상황에서 Partial을 사용해 해당 값이 undefined일 수 있는 상태를 표현할 수 있음.

```tsx
type PartialRecord<K extends string, T> = Partial<Record<K, T>>;
type Category = string;
...

foodByCategory["양식"].map((food) => console.log(food.name));
//Object is possibly 'undefined'
```

- 해당 값이 undefined일 수 있다고 컴파일 단계에서 알려줌.
- 이를 통해 옵셔널 체이닝 혹은 분기 처리를 통해 예상치 못한 런타임 오류를 줄일 수 있다.
