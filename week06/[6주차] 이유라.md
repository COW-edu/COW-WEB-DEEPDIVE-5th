# 6장. 타입스크립트 컴파일

### 6장

타입스크립트가 웹 브라우저에서 실행되기 위해서는 자바스크립트로 변환되어야 한다. 타입스크립트가 실행되는 전반적인 구조에 대해 알아보자.

- 6.1. 관련 기본 개념

  1. **런타임과 컴파일 기본 개념**

     1. 프로그래밍 언어의 구분

        프로그래밍 언어는 고수준 언어(High-Level)와 저수준 언어(Low-Level)로 나뉜다. 고수준 언어 내에서는 프로그래밍 언어 실행 방식에 따라 컴파일 언어와 인터프리터 언어로 나뉜다.

        - 고수준 언어: 사람이 이해하기 쉬운 언어
          - 특징
            - 하드웨어 독립적
            - 자연어에 가깝고 문법이 직관적이다.
            - ⭐️ 컴파일러나 인터프리터를 사용하여 기계어로 변환해야 실행이 가능하다.
            - 예시) Python, JavaScript
          - 실행 방식에 따른 구분
            | | | 실행 속도 | 오류 예측 |
            | --------------- | ------------------------------------------------------------- | --------------- | ----------------------------------- |
            | 컴파일러 언어 | 컴파일러가 전체 소스코드를 한 번에 기계어로 변환 후 실행한다. | 상대적으로 빠름 | 컴파일 시 문법 오류를 잡을 수 있다. |
            | 인터프리터 언어 | 인터프리터가 소스코드를 한 줄씩 해석하며 바로 실행한다. | 상대적으로 느림 | 런타임 중 오류가 발생할 수 있다. |
        - 저수준 언어: 컴퓨터가 이해하기 쉬운 언어
          - 특징
            - 하드웨어 의존적
            - 실행 속도가 빠른 편이다.
          - 예시) 기계어, 어셈블리어

     b. 컴파일 타임과 런타임

     - 컴파일 타임 (Compile Time)
       - 소스코드 → 기계어로 변환 by 컴파일러
       - 번역이 이루어지는 단계를 의미한다.
     - 런타임 (Runtime)
       - 컴파일을 마친 응용 프로그램이 실제로 메모리에 올라가 실행되는 시간
       - 프로그램이 실제 작동하는 단계를 의미한다.

  2. **자바스크립트 런타임**
     - 자바스크립트가 실행되는 환경을 의미한다.
       대표적인 런타임:
       - 브라우저 런타임: Chrome, Safari 등
       - Node.js 런타임: 서버 측 실행 환경
     - 구성요소
       - 자바스크립트 엔진 : V8 (코드 해석 및 실행 담당)
       - 웹 API: DOM, Timer, AJAX 등 브라우저가 제공하는 기능을 말한다.
       - 콜백 큐, 이벤트 루프, 렌더 큐 등: 비동기 처리를 위한 큐와 순서를 관리한다.
     - **⚠️ 자바스크립트는 런타임만 있고 컴파일 타임은 없을까?**
       - NO!
       - 자바스크립트는 전통적으로 인터프리터 언어로 분류되지만, 현대 자바스크립트 엔진인 V8에서는 사전 컴파일 과정이 존재한다. 자바스크립트의 V3 엔진은 때때로 실행 속도를 향상하기 위해 컴파일 단계에서 JS 코드를 캐싱하기도 한다.
       - 즉, 자바스크립트는 **인터프리터 + 컴파일 하이브리드 방식이라고 볼 수 있다.**

- 6.2. 타입스크립트 컴파일
  타입스크립트의 컴파일러 명칭은 `tsc`이다.
  - 타입스크립트는 `.ts` 확장자가 붙은 파일을 컴파일 하여 `.js`확장자가 붙은 JS 파일로 만들기 때문에, 고수준언어에서 고수준 언어로 변환되는 점을 보아 **트랜스파일**이라고 부르기도 한다.
  - 타입스크립트의 전반적인 실행 과정은 다음과 같다.
    | 단계 | 설명 | 사용 도구 | 실행 시점 |
    | ----- | ---------------------------------------------------------------------------------------------------- | ------------------------ | ----------- |
    | 1단계 | 타입스크립트 소스코드를 파싱하여 **TypeScript AST** 생성 | `tsc` | 컴파일 단계 |
    | 2단계 | 타입 검사기가 AST를 확인하여 **타입을 검사** | `tsc` (TSC Binder 사용) | 컴파일 단계 |
    | 3단계 | TypeScript AST를 기반으로 **JavaScript 코드로 트랜스파일** | `tsc` | 컴파일 단계 |
    | 4단계 | JS 코드를 런타임이 파싱하여 **자체 JS AST** 생성 | JavaScript 엔진 (예: V8) | 런타임 단계 |
    | 5단계 | JS AST는 런타임 엔진에 의해 바이트 코드로 변환된 후, **JIT 컴파일을 통해 최적화된 머신 코드로 변환** | JavaScript 엔진 | 런타임 단계 |
    | 6단계 | 생성된 코드를 기반으로 **프로그램 실행** | JavaScript 엔진 | 런타임 단계 |
    \*JIT 컴파일: Just-In-Time 컴파일은 프로그램이 실행되는 런타임 시점에 중간 단계 코드인 바이트 코드를 최적화된 머신 코드로 변환하는 방식이다.
    → ⭐️ 그렇다면 바이트 코드와 머신 코드의 차이점은 무엇일까?
    | 구분 | 바이트 코드 (Bytecode) | 머신 코드 (Machine Code) |
    | -------------------- | ----------------------------------------------------- | ------------------------------------------ |
    | **정의** | 가상 머신(VM)이 이해하고 실행할 수 있는 중간 코드 | **CPU**가 직접 이해하고 실행하는 이진 코드 |
    | **실행 주체** | Java Virtual Machine (JVM), JS 엔진 등 **소프트웨어** | 실제 컴퓨터의 **하드웨어(CPU)** |
    | **사전 컴파일 여부** | 플랫폼 독립적 중간 코드 (보통 컴파일러가 생성) | 플랫폼에 따라 다름, 하드웨어 의존 |
    | **속도** | 빠르지만, 머신 코드보다 느림 | 가장 빠름 (직접 실행) |
    | **예시** | `.class` (Java), JS 엔진 바이트코드 | x86, ARM 명령어 |
  - 컴파일러의 기능
    `타입스크립트 컴파일러(tsc)`는 다음 두 기능을 동시에 수행한다.
    1. 정적 타입 검사기 (Static Type Checker)
    2. 트랜스파일러 (Transpiler)
       ⭐️ 두 기능은 **논리적으로 분리되어 있지만**, 기술적으로는 같은 컴파일 과정 안에서 **순차적으로 처리된다.**
    - **코드 검사기로서의 타입스크립트 컴파일러 : 타입 검사**
      - `tsc`는 `binder`를 사용하여 코드의 정적 타입을 검사한다.
      - 이를 통해 JS 런타임에서 발생할 수 있는 오류를 사전에 방지할 수 있다.
      - 자바스크립트에서는 실행 중에나 발견 가능한 오류를, 타입스크립트는 컴파일 타임에 미리 찾아 런타임 에러를 방지할 수 있습니다.
    - **코드 변환기로서의 타입스크립트 컴파일러 : 트랜스파일**
      - 타입스크립트 코드는 런타임에서 직접 실행될 수 없기 때문에, 타입스크립트를 파싱하고 JS 코드로 변환(transpile)해야 한다.
      - 따라서 `tsc`는 TS 코드를 파싱 후, JS 버전에 맞춰 변환한다.
        - 이때 타입스크립트 컴파일러의 `target` 옵션을 사용하여 특정 버전의 JS 코드로 컴파일이 가능하다.
        ```tsx
        {
          "compilerOptions": {
            "target": "ES5",           // 변환할 JS 버전 설정
            "strict": true,            // 엄격한 타입 검사 활성화 여부
            "noEmitOnerr": true
            // 타입 오류가 있는 경우 JS로 변환하지 않도록 막을 수 있음 (기본값은 false)
          }
        }
        ```
      - **⚠️ 주의할 점: 만약 코드에 타입 오류가 있다면 컴파일이 진행이 될까?**
        - YES!
        - 타입 오류가 있더라도 기본 설정에서는 컴파일이 진행된다.
        - 그 이유는 타입 검사와 자바스크립트 코드 변환 과정이 독립적으로 작동하기 때문이다.
        - 다만 위 설정 코드와 같이 `noEmitOnerr: true`로 지정하면, 타입 오류가 있을 경우 JS 코드가 생성되지 않도록 막을 수 있다.
  - **⭐️ TypeScript 컴파일러와 바벨의 차이점**
    | | 공통점 | 타입 검사 여부 |
    | ------------------- | ------------------------------------------------------------------------------------- | -------------- |
    | TypeScript 컴파일러 | ECMAScript 2015 이후의 코드를 현재 또는 오래된 브라우저와 호환되는 버전으로 변환한다. | O |
    | 바벨(Babel) |
    | - JS 컴파일러 | ECMAScript 2015 이후의 코드를 현재 또는 오래된 브라우저와 호환되는 버전으로 변환한다. | X |
- 6.3. 타입스크립트의 컴파일러 구조
  타입스크립트의 컴파일러는 ‘TS 소스코드 → JS 코드’로 변환하는 도구이다.
  변환 과정에서 정적 타입 검사도 수행되며, 모든 작업은 컴파일러 내부 구성 요소들에 의해 이뤄진다.
  - 컴파일러의 주요 구성요소 및 처리 단계
    | 단계 | 구성요소 | 설명 |
    | ----- | ------------------ | ---------------------------------------------------------------------------------------------- |
    | 1단계 | 프로그램 (Program) | tsc 명령어 실행 시 생성되는 컴파일 전체 컨트롤러 역할tsconfig.json을 기반으로 작동한다. |
    | 2단계 | 스캐너 (Scanner) | 어휘 분석(lexical analysis) 수행: 소스코드를 의미를 가진 최소 단위인 토큰(token)으로 분리한다. |
    | 3단계 | 파서 (Parser) | 구문 분석(syntax analysis) 수행: 토큰들을 AST 구조로 변환한다. |
    | 4단계 | 바인더 (Binder) | AST의 노드를 탐색해 심벌 정보를 수집하여 타입 검사에 필요한 데이터 구조를 생성한다. |
    | 5단계 | 체커 (Checker) | 심벌 + AST 기반으로 정적 타입 검사를 수행한다. |
    *심벌 from 파서
    *AST from 바인더 |
    | 6단계 | 이미터 (Emitter) | 타입 오류가 없다면 최종적으로 JS 코드로 변환한다. |
    \*AST(Abstract Syntax Tree): 소스코드를 분석한 결과로 만들어지는 트리 구조의 데이터로, 컴파일러가 ‘어휘 분석 → 구문 분석’을 거쳐 생성한다.
  - 컴파일 과정 순서 정리
    1. tsc 명령어 실행 → 프로그램 객체 생성
    2. 스캐너가 토큰을 분리
    3. 파서가 AST 생성
    4. 바인더가 AST 노드에 심벌 생성
    5. 체커가 타입 검사 수행
    6. 에러가 없다면 이미터가 JS 코드로 변환
- **6장 최종 정리**
    <aside>
    💡
    타입스크립트는 컴파일 과정에서 총 6단계를 거쳐 타입 검사와 자바스크립트 코드로의 변환을 수행하고, 런타임에서는 자바스크립트 코드가 바이트코드로 변환되어 인터프리트 방식으로 실행된다. 이 중 반복적으로 실행되는 코드는 JIT(Just-In-Time) 컴파일을 통해 최적화된 머신 코드로 변환되어 더 빠르게 실행된다.
    
    </aside>

---

<br/>

# 7장. 비동기 호출

웹 프론트엔드는 주로 HTTP 프로토콜을 통해 백엔드와 통신한다. 이때 API를 요청하고 응답받는 행위는 모두 비동기적으로 이루어진다. 따라서 비동기 처리와 관련된 지식을 습득해 보자.

<aside>
💡 알아야 할 내용

1.  현재 비동기 동작이 어떤 상태일까?
2.  비동기 동작을 위해 필요한 정보는 어떤 게 있을까?
3.  요청이 성공했다면 받아온 정보는 어떻게 저장하고 관리할 수 있을까?
4.  요청이 실패했다면 실패에 대한 정보는 어떻게 확인할까?
5.  비동기 요청에 대한 코드를 쉽게 유지보수할 수 있도록 어떻게 구조화할 수 있을까?
</aside>

- 7.1. API 요청 방법
  TypeScript로 API 응답을 처리하고 타입 안정성을 높이고 유지보수를 용이하게 하는 방법들에 대해 알아보았다.

  1. **`fetch`로 API 요청**
     - 필요 배경: 가장 기본적인 API 호출 방식으로, 외부 라이브러리 없이 간단하게 사용이 가능하다.
     - 사용 예시
       ```tsx
       async function logJSONData() {
         const res = await fetch("http://example.com/movies.json");
         const jsonData = await res.json();
         console.log(jsonData);
       }
       ```
     - 문제점
       - 여러 컴포넌트에서 같은 API URL을 중복 사용 → 재사용성 낮음
       - ⭐️ API 요청 정책이 바뀔 때마다 모든 호출부 코드를 수정해야 한다.
  2. **서비스 레이어로 분리하기**
     - 필요 배경: 컴포넌트에 비즈니스 로직이 섞여 있을 경우 유지보수가 어렵고 테스트가 용이하지 않다.
       - API 호출 로직을 별도의 서비스 레이어로 분리해 관리한다.
         - 서비스 함수 안에서 `fetch` 호출
         - 컴포넌트는 결과만 받아 사용
           → 효과: API 정책이 바뀌어도 서비스만 수정하면 된다.
     - 예시
       - `fetch` 함수 호출 로직을 서비스 레이어로 이동하고, 컴포넌트는 서비스 레이어의 비동기 함수를 호출해 응답을 받아 렌더링한다.
  3. Axios 활용하기

     - 필요 배경
       - fetch보다 기능 확장에 유리해 권장되는 방식이다.
     - Axios 인스턴스로 공통 설정(baseURL, timeout, 헤더) 을 관리할 수 있다.
       →효과: 코드 중복 감소 및 유지보수 용이함

       ```tsx
       const apiRequester = axios.create({
         baseURL: "https://api.baemin.com",
         timeout: 5000,
       });

       const fetchCart = () => apiRequester.get("cart");
       ```

  4. Axios 인터셉터 이용하기

     - 필요 배경
       - 서버가 여러 개일 경우 요청별로 헤더나 인증 방식이 다르다.
       - 요청이 많아질수록 반복 코드와 조건 분기가 많아져 복잡도가 증가한다.
       - API 요청 구조를 선언형 + 체이닝으로 개선하고 싶을 때 사용한다.
     - 문제 해결
       아래의 방법들을 사용하면 유지보수성, 가독성 측면에서 코드 품질이 향상된다.

       - Axios 인터셉터(Interceptor) 사용

         - `axios.create()`로 `requester`를 여러 개 생성하여 서버별 요청에 기본 헤더, 토큰, 쿠키 등 공통 설정을 자동으로 추가한다.
         - 요청과 응답에 대해 미리 처리 로직 삽입 가능

         ```tsx
         const apiRequester = axios.create({
           baseURL: "https://api.baemin.com",
           timeout: 5000,
         });

         // 기본 헤더 설정
         const setRequestDefaultHeader = (config) => {
           config.headers = {
             ...config.headers,
             "Content-Type": "application/json;charset=utf-8",
             user: getUserToken(),
             agent: getAgent(),
           };
           return config;
         };

         // 인터셉터 연결
         apiRequester.interceptors.request.use(setRequestDefaultHeader);
         ```

       - APIBuilder 패턴 사용

         - 각 요청을 체이닝 방식으로 선언형 구성이 가능하도록 하는 디자인 패턴
         - 요청마다 필요한 옵션만 골라 설정이 가능하다. (유연성)

         ```tsx
         const api = APIBuilder.get("/apis/web/jobs")
           .withCredentials(true) // withCredentials 필요 시 자동 설정
           .params({ name, size }) // 쿼리 파라미터 추가
           .build();

         const { data } = await api.call(); // 호출
         ```

         - `APIBuilder` 내부적으로 Axios 인스턴스를 생성하고 필요한 설정을 조립한다.
         - `withCredentials`이 true라면, 자동으로 인터셉터를 통해 401 오류 처리도 할 수 있다.

  5. API 응답 타입 지정하기
     - 여러 API에 공통된 구조가 있다면 이를 공통된 타입 구조로 추상화하면 유지보수가 쉬워진다.
     - `res<T>` 구조로 통일하면 타입 선언과 검증에 용이하다.
       ```tsx
       interface res<T> {
         data: T;
         status: string;
         serverDateTime: string;
         errCode?: string;
         errMessage?: string;
       }
       ```
     - ⚠️ 주의: res 타입을 광범위하게 설정하면 응답이 없는 API에도 무조건 데이터가 있다고 가정할 수 있다.
       - 따라서 응답 타입이 애매할 경우에는 `unknown`으로 분리하거나 클라이언트 로직과 분리해야 한다.
  6. 뷰모델 사용하기

     - 필요배경
       - 서버 응답이 자주 바뀌는 경우에는 프론트 UI 로직이 영향을 받을 수 있다.
         → 응답을 VIiewModel로 감싸서 변환하여 안정성을 향상할 수 있다.
     - 예시

       - 뷰모델 없이 사용하면
         ```tsx
         const { items } = await fetchList();
         setItems(items); // 'items' 이름이 API마다 다르면 수정 필요
         ```
         - API에서 items라는 필드 이름이 바뀌거나 의미가 달라질 경우 UI 코드도 수정해야 하는 번거로움이 있다.
       - 따라서 뷰모델을 사용해 보자.

         ```tsx
         class JobList {
           totalItemCount: number;
           items: JobListItem[];

           constructor({ jobItems }: JobListres) {
             this.totalItemCount = jobItems.length;
             this.items = jobItems.map((item) => new JobListItem(item));
           }
         }
         ```

         - 서버 응답 형태와 상관없이 프론트에서 사용되는 도메인 구조로 API 응답을 가공할 수 있다.

  7. Superstruct로 런타임에서 응답 타입 검증하기

     - 필요 배경
       - TypeScript는 컴파일 타임에만 타입을 보장하기 때문에, 실제 API 응답이 다를 경우 런타임에서 유효성 검증이 따로 필요하다.
     - Superstruct를 사용하면 런타임 유효성 검증이 가능하다.

       ```tsx
       import { assert, object, number, string, array } from "superstruct";

       const Article = object({
         id: number(),
         title: string(),
         tags: array(string()),
         author: object({ id: number() }),
       });

       assert(data, Article);
       //assert: data와 Article이 일치하지 않으면 에러를 반환한다.
       ```

     - 이때, 유효성 검사를 도와주는 모듈 3가지를 정리해 보면 다음과 같다.
       1. assert : 유효하지 않을 경우 에러(throw)를 반환한다.
       2. is : 유효성 검사 결과에 따라 boolean을 반환한다.
       3. validate: [err, data] 형식의 튜플을 반환한다.
     - `Infer`을 사용하면 Superstruct 기반의 타입 정의도 가능하다.

- 7.2. API 상태 관리하기
  API를 호출할 때 발생하는 성공, 실패, 로딩 상태를 전역 관리하는 방식에 대해 알아보았다.

  1. **상태 관리 라이브러리에서 호출하기 (Redux, MobX)**
     - 필요 배경: API 호출에 따른 상태(로딩, 성공, 실패 등)를 여러 컴포넌트에서 공유하거나 제어할 필요가 있음
     - Redux
       - 장점:
         - 상태를 “액션”이라는 이벤트를 사용하여 명시적으로 관리할 수 있다.
         - 크고 복잡한 애플리케이션에서 확장성이 높다.
       - 단점:
         - 미들웨어 설정, 액션 추가 등 보일러플레이트 코드가 많아질 수 있다.
         - 비동기 상태 관리에는 다소 번거로움이 있다.
     - MobX
       - 장점:
         - `makeAutoObservable`, `runInAction` 등을 통해 간단하게 상태를 관리할 수 있다.
         - 비동기 흐름 관리가 자연스럽고 코드가 간결하다.
  2. **훅으로 호출하기 ( react-query, SWR )**

     - 필요 배경: 비동기 상태를 간단하게 관리하고, 캐시 기반으로 중복 요청을 방지하기 위해 사용된다.
     - 상태가 UI와 밀접한 경우 react-query 사용이 적절하다.
     - 장점:
       - 상태 자동 캐싱 및 업데이트
       - `invalidateQueries`로 특정 데이터를 자동 갱신한다.
       - 풀링 polling이나 웹소켓 websocket 방식도 손쉽게 적용이 가능하다.

     \*풀링(poolling): 클라이언트가 주기적으로 서버에 요청을 보내 데이터를 업데이트하는 걸 말한다. 클라이언트는 일정한 시간 간격으로 서버에 요청을 보내고, 서버는 해당 요청에 대해 최신 상태의 데이터를 응답으로 보내준다.

  3. 두 방식 비교 요약
     - Redux vs react-query
       - Redux는 모든 상태를 중앙에서 제어하지만, 복잡도와 보일러플레이트가 크다.
       - react-query는 API 상태 관리에 특화되어 있고, 캐시/자동 갱신에 강함.
     - 어떤 것을 써야 할까?
       - 서버 상태를 다루는 데는 `react-query`, `SWR`이 적합하다.
       - UI 상태나 전역 도메인 상태는 `Redux`, `MobX`, `Recoil` 등이 적합하다.
       - 주어진 상황에 따라 병행 사용도 고려할 수 있다.

- 7.3. API 에러 핸들링
  API 호출 시 400번대, 500번대, CORS 등 다양한 에러가 발생할 수 있다. 따라서 에러 처리를 위해 명시적이고 일관적이게 처리하는 구조를 도입해야 한다. 이때, 상태 코드에 따라 클라이언트가 대응할 수 있도록 타입스크립트와 Axios, 커스텀 에러 클래스, 인터셉터, 에러 바운더리 등을 활용할 수 있다.

  1. **라이브러리 내장 타입 가드 활용**

  - Axios에 내장되어 있는 `isAxioserr` 타입가드를 활용하여 사용자 정의 타입 가드를 만들 수 있다.
  - 언제?
    - **서버 에러** 대응
  - 예시

    ```tsx
    interface errres {
      status: string;
      serverDateTime: string;
      errCode: string;
      errMessage: string;
    }

    function isServererr(err: unknown): err is Axioserr<errres> {
      return axios.isAxioserr(err);
    }
    ```

    - `err is Axioserr<errres>` : 사용자 정의 타입 가드 (type predicate)

  - 장점
    - `err.res?.data` 타입을 명시적으로 인식해 안전한 접근이 가능하다.
    - 공통 에러 구조 기반으로 일관된 에러 메시지를 처리할 수 있다.

  1. 에러 서브클래싱 (Subclassing)

  - 언제?
    - **서버 에러** 대응
  - 방법
    - 에러 유형별로 클래스를 나눠 처리한다.
    ```tsx
    class Networkerr extends err { ... }
    class Timeouterr extends err { ... }
    class Unauthorizederr extends err { ... }
    ```
    - 에러 핸들링 함수에서 `instanceo`f로 구분한다.
    ```tsx
    if (err instanceof Networkerr) {
    	... //네트워크 관련 메시지
    }
    ```
  - 장점
    - 에러 상황에 맞는 구체적인 처리를 할 수 있다.
    - `throw new Specificerr()`를 통해 에러 전달 구조를 명확히 할 수 있다.

  1. 라이브러리 내장 인터셉터를 활용한 공통 에러 처리
     - 언제?
       - **HTTP 에러**에 대한 공통 로직을 각 호출마다 중복 처리하지 않기 위해 인터셉터를 사용한다.
     - 예시
       ```tsx
       axiosInstance.interceptors.res.use(
         (res) => res,
         (err) => {
           if (err.res?.status === 401) {
             window.location.href = "/login";
           }
           return Promise.reject(err);
         }
       );
       ```
     - 장점
       - 모든 API 응답에 대해 공통 에러 처리가 가능하다.
       - 코드의 중복을 줄일 수 있다.
  2. 에러 바운더리를 활용한 예외 처리
     - 언제?
       - **리액트 컴포넌트 트리**에서 발생한 에러 대응 → 공통으로 에러 처리
       - 즉, 컴포넌트 내부에서 예상하지 못한 에러가 발생할 경우 UI 보호를 위해 사용한다.
     - 방법
       - 해당 에러를 가장 가까운 부모 에러 바운더리에서 처리한다.
         ```tsx
         class errBoundary extends React.Component {
           static getDerivedStateFromerr() { return { haserr: true }; }
           componentDidCatch(err, info) { ... }
           render() { return this.state.haserr ? <errPage /> : this.props.children; }
         }
         ```
     - 장점
       - 렌더링 중 발생하는 예외 처리가 가능하다.
       - 사용자에게 친절한 에러 메시지나 에러 페이지를 제공할 수 있다.
  3. 상태 관리 라이브러리에서 에러 처리
     - Redux의 에러 처리 방법
       - `createSlice()` 로 에러 상태를 관리한다.
       - API 호출 전후에 에러 시 상태를 `dispatch()`로 업데이트한다.
       - Axios 인터셉터에서 공통적으로 처리가 가능하다.
       ```tsx
       const apiCallSlice = createSlice({
         name: "apiCall",
         reducers: {
           setApiCall,
           setApiCallerr, // 에러 상태 저장
         },
       });
       ```
       - 인터셉터 내부에서
         - 성공 시: setApiCall(status: None)
         - 실패 시:
           - 401/403 → 자동 리다이렉트 수행
           - 기타 에러 → 에러 메시지 출력 + setApiCallerr(err)
     - MobX의 에러 처리 방법
       - Store 내부에서 try/catch 처리
       - `runInAction()`을 사용해 상태 변경
       - 에러 핸들링이 Store 안에 포함된다.
         ```tsx
         try {
           const result = await fetchJobList();
           runInAction(() => {
             this.jobs = result;
             this.state = "DONE";
           });
         } catch (e) {
           runInAction(() => {
             this.state = "err";
             this.errMsg = e.message;
           });
         }
         ```
  4. Reacy Query의 에러 처리 방법
     - useQuery() 내부에서 err, iserr로 에러 상태를 확인할 수 있다.
     - 상태 분기가 없어도 간편하게 에러 처리가 가능하다.
       ```tsx
       if (iserr) return <div>{err.message}가 발생했습니다.</div>;
       ```
  5. 그 밖의 에러 처리 방법

     - 방법
       - 커스텀 에러를 만들어 에러를 처리할 수 있다.
     - 예시

       - 문제 상황
         - 커스텀 에러는 200 응답 코드와 응답 바디에 상태 코드를 전달하고 있다. 이 상황에서 커스텀 에러를 어떻게 구현해서 에러를 처리해야 할까?
           ```tsx
           //예시
           {
           	"status": "C20005", //성공일 때만 "SUCCESS" 응답
           	"message": "장바구니에 품절된 메뉴가 있습니다!"
           }
           ```
       - 해답

         - 응답 상태를 조건문으로 검사하여, 실패 시 Cystomerr를 던질 수 있다.
         - 예시 코드

           ```tsx
           const successHandler = (res: CreateOrderres) => {
             if (res.status !== "SUCCESS") {
               //성공시 로직
               return;
             }
             throw new Customerr(res.status, res.message);
           };

           const CreateOrder = (data: CreateOrderData) => {
             try {
               const res = apiRequester.post("https://~, data");
               successHandler(res);
             } catch (err) {
               errHandler(err);
             }
           };
           ```

     - 해답에 대한 2차 문제상황
       - 처리해야 하는 API가 많을 경우 매번 성공 로직을 구분하기 위해 if (res.status === “SUCCESS”) 구문을 추가해야 한다. ⇒ 코드 중복
     - 2차 문제상황 해결

       - `Axios`의 인터셉터(Interceptor) 기능을 활용하여 공통 응답 처리 로직을 모듈화한다.

         - API requester를 별도로 선언하고 상태 코드 비교 로직을 인터셉터에 추가한다.

         ```tsx
         // 1. Customerr 클래스 정의
         class Customerr extends err {
           constructor(public status: string, public message: string) {
             super(message);
             this.name = "Customerr";
           }
         }

         // 2. Axios 인스턴스 생성 및 인터셉터 등록
         export const apiRequester = axios.create({
           baseURL: orderApiBaseUrl,
           timeout: 5000,
         });

         // 3. 공통 응답 처리 인터셉터 추가
         apiRequester.interceptors.res.use(
           (res: Axiosres) => {
             // status 값이 SUCCESS가 아니면 에러로 판단
             if (res.data.status !== "SUCCESS") {
               throw new Customerr(res.data.status, res.data.message);
             }
             return res;
           },
           (err) => {
             return Promise.reject(err);
           }
         );
         ```

         - Customerr클래스
           - `status`, `message`를 인자로 받아 에러 객체를 생성한다.
           - JS의 기본 `err`클래스를 상속해서 `Customerr`로 사용한다.
           - [`this.name](http://this.name) = “Customerr”`로 에러 타입 구분을 한다.
         - Axios 인스턴스 생성 및 인터셉터 등록
           - axios.create()를 사용하여 별도의 인스턴스를 생성한다.
           - `baseURL`, `timeout`을 공통 설정으로 넣었다.
         - 응답 인터셉터
           - `res.use()`는 Axios의 기본 응답 인터셉터이다.
           - 응답 객체의 `data.status`값이 “SUCCESS”가 아닐 경우로 분류해, `Customerr`를 사용해 에러 처리를 한다.
           - 성공일 경우, res를 반환한다.
           - `err` 핸들러에서는 서버 에러는 `Promise.reject()`로 전달한다.

       - 호출부에서 처리
         ```tsx
         const createOrder = async (data: CreateOrderData) => {
           try {
             const response = await apiRequester.post("/orders", data);
             console.log("주문 성공!", response.data);
           } catch (error) {
             if (error instanceof CustomError) {
               alert(`주문 실패: ${error.message}`);
             } else {
               alert("예상치 못한 오류가 발생했습니다.");
             }
           }
         };
         ```
         - 주문 생성 API를 호출하는 비동기 함수
         - 인터셉터에서 성공/실패 여부를 이미 판단했기 때문에, 이 함수에서는 성공 로직만 작성한다.
         - 실패 시엔 `CustomError` 타입인 경우 메시지를 사용자에게 알린다.
         - 이외의 일반적인 네트워크 오류(타임아웃 등)는 `else`에서 처리한다.

- 7.4. API 모킹

  API 모킹에 대해 알아보자. 모킹이란 가짜 모듈을 활용하는 것을 말한다. 모킹은 테스트 할 때뿐 아니라 개발할 때도 사용할 수 있다. 프론트엔드 개발을 하다보면 서버 API가 만들어지기 전에 개발을 진행해야 하는 일이 발생한다. 따라서 개발하면서 다양한 예외 케이스의 응답을 편하게 테스트해 보기 위해 모킹을 활용할 수 있다.

  1. JSON 파일 불러오기
     - 언제 사용?
       - 간단한 조회만 필요할 경우
     - 방법
       - `.json` 파일을 만들거나 자바스크립트 파일 안에 JSON 형식의 정보를 저장하고 `export`해 주는 방식으로 사용할 수 있다.
       - 이후 GET 요청에 파일 경로를 삽입해 주면 조회 응답으로 원하는 값을 받을 수 있다.
     - 장점
       - 별도 환경 설정이 필요하지 않다.
       - 프로젝트 초기 단계에서 사용자의 인터렉션 없이 빠르게 목업을 구축할 수 있다.
     - 주의할 점
       - 추후 실제 API URL로 교체해야 한다.
  2. NextApiHandler 활용하기

  - 언제 사용?

    - Next.js 프로젝트에서 간단한 API 응답이 필요할 때 사용한다.
    - 파일 단위로 핸들러를 정의하여, 해당 파일의 경로가 곧 요청 경로가 된다.
    - 중간 서버 없이도 간단한 API 서버 역할을 수행할 수 있다.

  - 사용 방법

    - 하나의 파일 안에 하나의 핸들러를 default export로 구현
    - 응답하고자 하는 값을 정의하고, 요청에 대해 응답을 반환
    - 필요 시 응답 처리 로직 추가 가능

  - 방법

    - `.json` 파일을 만들거나 자바스크립트 파일 안에 JSON 형식의 정보를 저장하고 `export`해 주는 방식으로 사용할 수 있다.
    - 이후 GET 요청에 파일 경로를 삽입해 주면 조회 응답으로 원하는 값을 받을 수 있다.

  - 장점
    - 별도 환경 설정이 필요하지 않다.
    - 프로젝트 초기 단계에서 사용자의 인터렉션 없이 빠르게 목업을 구축할 수 있다.
    - 주의할 점
    - 추후 실제 API URL로 교체해야 한다.

  3. API 요청 핸들러에 분기 추가하기

  - 언제 사용?

    - 요청 경로를 수정하지 않고, 개발 중에는 목업(mock) 데이터를 사용하고 실제 운영 환경에서는 진짜 API를 호출하고 싶을 때 사용한다.
    - 유지보수 시에도 간편하게 실제 요청과 목업 요청을 조건에 따라 분기하여 처리할 수 있다.

  - 사용 방법

    - useMock과 같은 조건 변수에 따라 `mockFetchBrands()`와 같이 미리 정의한 목업 함수 또는 실제 API 요청 함수`(requester.get(...))`를 호출하도록 분기한다.

    - 개발 환경에서는 목업 데이터를 반환하고, 실제 운영 환경에서는 서버 API를 호출하게 된다.

  - 코드 예시

          ```tsx
          const mockFetchBrands = (): Promise<FetchBrandsResponse> =>
          new Promise((resolve) => {
              setTimeout(() => {
              resolve({
                  status: "SUCCESS",
                  message: null,
                  data: [
                  { id: 1, label: "배민스토어" },
                  { id: 2, label: "비마트" },
                  ],
              });
              }, 500);
          });

          const fetchBrands = () => {
          if (useMock) {
              return mockFetchBrands();
          }

          return requester.get("/brands");
          };
          ```

    - 장점

    - 개발 이후에도 테스트나 유지보수를 위해 목업 데이터를 쉽게 사용할 수 있다.

    - 실제 API 호출 없이 개발을 계속 진행할 수 있어 효율적이다.

    - 주의할 점
    - 모든 API 요청 함수마다 if 문으로 분기 처리를 해야 하기 때문에 코드가 번거롭고 반복적일 수 있다.

4. axios-mock-adapter로 모킹하기

   - 언제 사용?

     - 서비스 함수 내에 if 문 분기를 추가하지 않고, 외부 라이브러리로 깔끔하게 모킹(mocking)하고 싶을 때 사용

     - 개발 중인 서버의 응답을 시뮬레이션하거나 테스트 시 네트워크 오류 등을 발생시키고 싶을 때 유용

   - 사용 방법

     - `axios-mock-adapter` 라이브러리를 설치 후, MockAdapter 객체를 생성한다.

     - `onGet`, `onPost` 등의 메서드에 URL 패턴과 응답 값을 설정한다.

     - 조건 분기나 응답 지연, 상태 코드 등을 자유롭게 설정할 수 있다.

   - 장점

     - `axios-mock-adapter`를 사용하면 실제 요청 함수에 조건문을 넣지 않아도 됨

     - 다양한 HTTP 메서드(GET, POST, PUT, DELETE 등)에 대한 목업 가능

     - 지연 시간, 상태 코드, 에러 발생 등을 자유롭게 설정할 수 있음

     - 테스트 환경에서 API 호출 실패 케이스를 시뮬레이션할 수 있음

5. 목업 사용 여부 제어하기

   - 언제 사용?

     - 로컬(local)에서는 목업을 사용하고, 운영(dev/production) 환경에서는 사용하지 않을 때

     - 플래그 변수를 통해 코드에서 분기 없이 목업 사용 여부를 제어하고 싶을 때

     - 프론트엔드와 백엔드가 독립적으로 개발될 수 있도록 설정하고 싶을 때

   - 사용 방법

     - `.env` 또는 환경 변수 사용 (REACT_APP_MOCK)

     - 조건부로 `mockFn()` 실행

   - 장점

     - 실행 스크립트에서 제어 가능하여 코드 수정 없이 손쉽게 환경 전환 가능

     - 로컬에서는 목업 사용, dev 서버 필요 시는 dev 서버를 바라보도록 분기 설정 가능

     - 프론트와 백엔드 개발을 독립적으로 진행 가능

   - 주의할 점

     - `axios-mock-adapter` 는 실제 API 요청을 보내지 않기 때문에 브라우저 개발자 도구(Network 탭) 에서 확인이 어렵다.

     - API 요청 흐름을 확인하려면 `react-query-devtools`, `redux test tool` 또는 `Cypress` 같은 도구 활용 필요

     - 요청을 시각적으로 확인하고 싶을 땐 webhook 기능을 사용하는 것도 방법

\*Cypress:

    - 자바스크립트 기반 오픈 소스 E2E 테스트 도구
    - 웹 애플리케이션의 사용자 동작을 시뮬레이션하고 테스트하는 데 적합
    - 강력한 기능으로 견고하고 안정적인 앱 개발을 지원a
    - 네트워크 요청을 캡처, 조작, 대체 응답(mock) 가능

\*기타 모킹 방식: MSW (Mock Service Worker)

    - 브라우저 또는 Node 환경에서 서비스워커로 요청을 가로채고 모킹
    - API 통신 흐름이 개발자 도구(Network) 에서 그대로 보여 편리함
    - 목업/개발/운영 환경 분리를 명확하게 할 수 있음
