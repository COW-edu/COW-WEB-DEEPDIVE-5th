# 6장 타입스크립트 컴파일

## 자바스크립트 런타임과 타입스크립트의 컴파일

### 런타임 & 컴파일타임

- **컴파일타임(Compile Time)**
  - 소스코드가 실행 가능한 코드(예: 자바스크립트)로 변환되는 시점
  - 타입 체크, 문법 검사 등 정적 분석이 이루어짐
- **런타임(Runtime)**
  - 프로그램이 실제로 실행되는 시점
  - 런타임 에러, 동적 동작 등이 발생

### 자바스크립트 런타임

- 자바스크립트 코드를 실행하는 환경 (브라우저, Node.js 등)
- 주요 구성 요소
  - 자바스크립트 엔진(V8, SpiderMonkey 등)
  - Web API, 콜백 큐, 이벤트 루프 등
- 코드 실행 중 발생하는 에러는 런타임 에러

### 타입스크립트 컴파일

- 타입스크립트는 tsc라고 불리는 컴파일러를 통해 자바스크립트 코드로 변환된다.
- 타입스크립트 컴파일시 TypeScript → JavaScript로 변환 즉 고수준언어 → 고수준언어로 변환된다. 따라서 이를 컴파일이 아닌 트랜스파일 혹은 소스 대 소스 컴파일러라고 불리기도한다.
- 타입스크립트 컴파일러는 소스코드 해석 → 타입스크립트 AST 생성 → 타입 확인 → 자바스크립트 코드 변환 이 진행된다.
- 런타임에서 변환된 자바스크립트 코드 → 자바스크립트 AST 생성 → 바이트 코드 변환 → 바이트 코드 평가 및 프로그램 실행 과정을 거쳐 프로그램이 실행된다.
- `AST`: 컴파일러가 소스코드를 해석하는 과정에서 생성된 데이터 구조이다. lexical analysis, syntax analysis 과정을 거쳐 소스코드를 노드 단위의 트리 구조로 구성한다.
- 타입스크립트는 컴파일타임에 에러를 발견할 수 있는 정적 타입 검사기라 불리며 에러가 발생하면 프로그램이 실행되지 않는다.

## 타입스크립트 컴파일러의 동작

### 코드 검사기로서의 타입스크립트 컴파일러

- 컴파일타임에 코드 타입을 확인하기 때문에 코드를 실행하지않고 오류를 확인한다.
- 정적으로 코드를 분석하여 에러 검출하고, 실행 전 자바스크립트 런타임에서 발생할 수 있는 에러를 사전에 알려준다.
- 타입스크립트 컴파일러는 tsc binder를 사용하여 타입 검사를 하며 컴파일타임에 타입 오류를 발견한다. 이후 타입 검사를 거쳐 코드를 안전하게 만든 이후 타입스크립트 AST를 자바스크립트로 코드로 변환한다.

### 코드 변환기로서의 타입스크립트 컴파일러

- 타입스크립트 컴파일러는 타입을 검사하고 타입스크립트 코드를 런타임 환경에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일한다.
- tsconfig.json에 `compilerOptions`의 `target` 옵션을 통해 해당 버전의 자바스크립트 소스코드로 컴파일할 수 있다.
- 트랜스파일이 완료된 자바스크립트 파일에서 타입 정보가 제거되고, 자바스크립트로 컴파일 되어야 브라우저가 코드를 이해하고 실행할 수 있다.
- 트랜스파일이 완료된 자바스크립트 파일에서 타입 정보가 모두 제거되기 때문에 런타임에서 타입이 아무 효력을 발휘하지 못한다.

```tsx
interface Square {
  width: number;
}

interface Retangle extends Square {
  height: number;
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    return shape.width * shape.height;
  } else {
    return shape.width * shape.width;
  }
}
```

- 위 코드를 변환하면 아래 코드처럼 변환된다. 이때 `Rectangle`은 타입이기 때문에 자바스크립트에서 해당 타입을 이해하지 못한다.

```tsx
function calculateArea(shape) {
  if (shape instanceof Rectangle) {
    return shape.width * shape.height;
  } else {
    return shape.width * shape.width;
  }
}
```

## 타입스크립트 컴파일러의 구조

- 타입스크립트 컴파일러는 아래 다섯 단계를 거쳐 타입검사와 자바스크립트 소스 변환을 진행한다.
- (프로그램) → 스캐너 → 파서 → 바인더 → 체커 → 이미터
  1. 프로그램: tsc명령어를 실행하여 프로그램 객체가 컴파일 과정을 시작
  2. 스캐너: 소스 파일을 토큰 단위로 분리한다.
  3. 파서: 토큰을 이용하여 AST를 생성한다.
  4. 바인더: AST의 각 노드에 대응하는 심볼을 생성한다. 심볼은 선언된 타입의 노드 정보를 담고있다.
  5. 체커: AST를 탐색하면서 심볼 정보를 활용하여 타입 ㄱ머사를 수행한다.
  6. 이미터: 타입 검사 결과 에러가 없으면 자바스크립트 소스 파일로 변환한다.

### 프로그램

- tsc 명령어로 타입스크립트 컴파일러가 실행된다.
- tsconfig.json에 명시된 컴파일 옵션을 기반으로 컴파일을 수행한다.
- 컴파일 과정을 관리하는 프로그램 객체를 생성하고 컴파일할 타입스크립트 소스 파일과 소스파일 내에서 임포트된 파일을 불러온다.

### 스캐너

- 타입스크립트 소스 파일을 어휘적으로 분석하여 토큰을 생성한다.

```tsx
const name = "junho";
```

- `const` → ConstKeyword
- `name` → Identifier
- `=` → EqualsToken
- `"junho"` → String Literal
- `;` → `SemicolonToken`

### 파서

- 스캐너가 만튼 토큰의 정보를 이용해 AST를 생성한다.
- 토큰 목록을 활용하여 syntax analysis를 수행하고, 노드 단위의 트리 형태로 표현한다.

```tsx
const name = "junho";

//위 코드를 AST로 변환시
{
  "type": "VariableDeclaration",
  "declarations": [
    {
      "type": "VariableDeclarator",
      "id": {
        "type": "Identifier",
        "name": "name"
      },
      "init": {
        "type": "Literal",
        "value": "junho",
        "raw": "\"junho\""
      }
    }
  ],
  "kind": "const"
}
```

### 바인더

- 체커 단계에서 타입 검사를 할 수 잇도록 기반을 마련.
- 심볼이라는 데이터 구조를 생성한다.
- 해당 심볼과 그에 대응하는 AST 노드를 연결하는 역할을 수행한다.

### 체커와 이미터

- 체커는 파서가 생성한 AST와 바인더가 생성한 심볼을 활용하여 타입 검사를 수행한다.
  - AST의 노드를 탐색하면서 심볼 정보를 불러와 주어진 소스 파일에 대해 타입 검사를 진행하는 역할이 체커의 주요 역할이다.
- 이미터: 타입스크립트 소스 파일을 변환하는 역할을 한다.
  - .ts → `.js` & `d.ts`로 변환

---

# 7장 비동기 호출

## API요청

```tsx
const CartBadge: React.FC = () => {
  const [cartCount, setCartCount] = useState(0);

  useEffect(() => {
    fetch("~~~").then(({ cartItem }) => {
      setCartCount(cartItem.length);
    });
  }, []);
};
```

- 위 컴포넌트는 백엔드의 변경 요구에 취약한 단점 존재함.
- 비동기 호출 코드는 컴포넌트 영역에서 분리되어 다른 영역에서 처리되어야한다.
- fetch함수를 서비스 레이어로 분리하고, 컴포넌트르는 해당 비동기 함수를 호출해 결과를 받아와 렌더링하는 흐름으로 생성된다.

```tsx
async function fetchCart() {
	const controller = new AbortController();
	const timeoutId = setTimeout(() => controller.abort(), 5000);
	return await fetch("~~~", {
		signal: controller.signal;
	});
}
```

- 그러나 단순 fetch 함수 분리로 API 요청 정책이 추가되는 것을 해결하기 어려움.
- 쿼리 파라미터, 커스텀 헤더 추가, 쿠키 읽고 토큰 집어넣는 등 API정책 추가시 이를 모두 구현하기 어려움.

### Axios 활용하기

```tsx
const apiRequester: AxiosInstance = axios.create({
  baseUrl: "~~~",
  timeout: 5000,
});

const fetchCart = (): AxiosPromise<FetchCartResponse> =>
  apiRequester.get<FetchCartResponse>("cart");

const postCart = (
  postCartRequest: PostCartRequest
): AxiosPromise<PostCartResponse> =>
  apiRequester.post<PostCartResponse>("cart", postCartRequest);
```

- API 요청 인스턴스를 따로 구성하게 만들 수도 있음.

```tsx
const apiRequester: AxiosInstance = axios.create(defaultConfig);

const orderApiRequester: AxiosInstance = axios.create({
  baseUrl: "~~~",
  ...defaultConfig,
});
const orderCartApiRequester: AxiosInstance = axios.create({
  baseUrl: "~~~",
  ...defaultConfig,
});
```

### Axios 인터셉터 사용하기

- 각각 requester는 서로 다른 역할을 담당하는 다른 서버이기에 requester별로 다른 헤더를 설정해줘야하는 로직이 필요할 수 있다.
- 인터셉터 기능을 사용해 requester에 따라 비동기 호출 내용을 추가해서 처리할 수 있다

```tsx
//interceptor 기능을 활용해 header를 설정하는 기능 넣기
apiRequest.interceptors.request.use(setRequestDefaultHeader);

//interceptor 기능을 활용해 API 에러 처리하기
orderApiRequester.interceptors.response.use(
  (response: AxiosResponse) => response,
  httpErrorHandler
);
```

- 요청 옵션에 따라 다른 인터셉터를 만들기 위한 빌더 패턴을 추가해 클래스 형태로 구성하기도 한다.
- 코드 보기
  - 실제 호출 부분 구성
  ```tsx
  class API
  	readonly method: HTTPMethod;
  	readonly url: string;
  	baseURL?: string;
  	headers?: HTTPHeaders;
  	params?: HTTPParams;
  	data?: unknown;
  	timeout?: number;
  	withCredentials?: boolean;

  	constructor(method: HTTPMethod, url: string) {
  		this.method = method;
  		this.url = url;
  	}

  	call<T>(): AxiosPromise<T> {
  		const http = axios.create();

  		if(this.withCredentials) {
  			http.interceptors.response.use(
  				response => response,
  				error => {
  					if (error.response & error.response.status === 401) {
  						//에러 처리 로직
  					}
  					return Promise.reject(error);
  				}
  			);
  		}

  		return http.request({...this});
  	}
  }
  ```
  - API 호출을 위한 래퍼 빌더 패턴
  ```tsx
  class APIBuilder {
    private _instance: API;

    constructor(method: HTTPMethod, url: string, data?: unknown) {
      this._instance = new API(method, url);
      this._instance.baseURL = apiHost;
      this._instance.data = data;
      this._instance.headers = {
        "Content-Type": "application/json; charset=utf-8",
      };
      this._instance.timeout = 5000;
      this._instance.withCredentails = false;
    }

    static get = (url: string) => new APIBuilder("GET", url);
    static put = (url: string, data: unknown) =>
      new APIBuilder("PUT", url, data);
    static post = (url: string, data: unknown) =>
      new APIBuilder("POST", url, data);
    static delete = (url: string) => new APIBuilder("DELETE", url);

    baseURL(value: string): APIBuilder {
      this._instance.baseURL = value;
      return this;
    }

    headers(value: HTTPHeaders): APIBuilder {
      this._instance.headers = value;
      return this;
    }

    timeout(value: number): APIBuilder {
      this._instance.timeout = value;
      return this;
    }

    params(value: HTTPParams): APIBuilder {
      this._instance.params = value;
      return this;
    }

    data(value: unknown): APIBuilder {
      this._instance.data = value;
    }

    withCredentails(value: boolean): APIBuilder {
      this._instance.withCredentails = value;
      return this;
    }

    build(): API {
      return this._instance;
    }
  }
  ```
  - 사용 코드 예시
  ```tsx
  fetchJobNameList = async (name?: string, size?: number) => {
    const api = APIBuilder.get("/apis/web/jobs")
      .withCredentail(true)
      .params({ name, size })
      .build();

    const { data } = await api.call<Response<JobNameListResponse>>();
    return data;
  };
  ```

### API 응답 타입 지정하기

- 같은 서버에서 오는 응답 형태는 통일 되어잇으면 하나의 Response 타입으로 묶일 수 있다.

```tsx
interface Reponse<T> {
  data: T;
  status: string;
  serverDateTime: string;
  errorCode?: string;
  errorMessage?: string;
}

const fetchCart = (): AxioosPromise<Response<FetchCartResponse>> =>
  apiRequester.get < Response < FetchCartResponse >> "Cart";

const postCart = (
  postCartRequest: PostCartRequest
): AxiosPromise<Response<PostCartResponse>> =>
  apiRequester.post<Response<PostCartResponse>>("cart", postCartRequest);
```

- Response타입을 apiRequester내에서 처리하게 되면 `UPDATE`, `CREATE`같이 응답이 없을 수도 있는 api를 처리하기 어려워진다.
- 즉 Response타입은 apiRequester가 모르게 관리되어야한다.
- 해당 값에 어떤 응답이 들어있는지 알 수 없거나 값의 형식이 달라지더라도 로직에 영향이 주지 않는 경우 unknown 타입을 사용하여 알 수 없는 값임을 표현한다.

```tsx
interface response {
  data: {
    cartItems: CartItem[];
    forPass: unknown;
  };
}
```

### View Model 사용하기

- 서버 스펙이 자주 바뀌는 경우 뷰모델을 사용하여 API 변경에 따른 범위를 한정해줘야한다.
- 좋은 컴포넌트는 변경될 이유가 하나뿐인 컴포넌트라고 말한다.
- API 응답이 변경되었을 때 컴포넌트에 API를 사용하는 컴포넌트가 수정되야 하는 상황이 발생하기에 이를 해결하기 위해 뷰 모델을 도입할 수 있다.

```tsx
interface JobListItemResponse {
  name: string;
}

interface JobListResponse {
  jobItems: JobListItemResponse[];
}

class JobList {
  readonly totalItemCount: number;
  readonly items: JobListItemResponse[];

  constructor({ jobItems }: JobItemResponse) {
    this.totalItemCount = jobItems.length;
    this.items = jobItems;
  }
}

const fetchJobList = async (
  filter?: ListFetchFilter
): Promise<JobListResponse> => {
  const { data } = await api
    .params({ ...filter })
    .get("/apis/get-list-summaries")
    .call<Response<JobListResponse>>();

  return new JobList(data);
};
```

- 뷰 모델을 만들어 API 응답이 바뀌어도 UI가 깨지지 않도록 개발할 수 있다.
- API 응답에 없는 새로운 필드를 만들어 사용할 때 서버에서 내려주는 응답과 실제 사용하는 도메인이 다르면 문제가 생길 수 있다.
- 백엔드-프론트엔드 개발자가 서로 소통해 API 응답 변화를 최대한 줄이기, 뷰 모델에 필드를 추가하는 대신 getter 함수를 추가해 어떤 값이 뷰 모델에 추가된 값인지 알기 쉽게 하기 등을 통해 변화에 유연하게 대처하기

## API 상태 관리하기

### 상태 관리 라이브러리에서 호출하기

- 상태 관리 라이브러리의 비동기 함수들은 서비스 코드를 사용하여 비동기 상태를 변화시킬 수 있는 함수를 제공.
- 컴포넌트는 상태를 구독하며 상태 변경시 컴포넌트를 리렌더링 하는 방식으로 동작한다.
- Redux, MobX, Zustand 등의 라이브러리를 통해 관리하고 호출한다.
- 전역 상태 관리자가 모든 비동기 상태를 접근하고 변경할 수 있기에 2개 이상의 컴포넌트가 구독하고 있는 비동기 상태가 있다면 의도치 않은 상태 변경이 일어날 수 있다.

### 훅으로 호출하기

- react-query, useSwr같은 훅을 사용하여 관리할 수 있다.
- 캐시를 사용하여 비동기 함수를 호출하며, 상태 관리 라이브러리에서 발생했던 의도치 않은 상태 변경을 방지하는데 도움이 된다.
- 코드보기
  ```tsx
  //job 목록 불러오기
  const useFetchJobList = () => {
    return useQuery(["fetchJobList"], async () => {
      const response = await JobService.fetchJobList();

      return new JobList(response);
    });
  };
  // job 1개 업데이트하는 훅
  const useUpdateJob = (
    id: number,
    {
      onSuccess,
      ...options
    }: UseMutationOptions<void, Error, JobUpdateFormValue>
  ): UseMutationOptions<void, Error, JobUpdateFormValue> => {
    const queryClient = useQueryClient();

    return useMutation(
      ["updateJob", id],
      async (jobUpdateForm: JobUpdateFormValue) => {
        await JobService.updateJob(id, jobUpdateForm);
      },
      {
        onSuccess: (
          data: void,
          values: JobUpdateFormValue,
          context: unknown
        ) => {
          queryClient.invalidateQueries(["fetchJobList"]);

          onSuccess && onSuccess(data, values, context);
        },
        ...options,
      }
    );
  };
  ```

## API 에러 핸들링

### 타입 가드 활용하기

- Axios라이브러리에서는 Axios 에러에 대해 isAxiosError라는 타입 가드를 제공한다.
- 이를 직접 사용할 수 있고, 서버 에러임을 명확히 표시하고 서버에서 내려주는 에러 응답 객체에 대해서도 구체적으로 정의함으로써 에러 객체가 어떤 속성을 가졌는지를 파악할 수 있다.

```tsx
function isServerError(error: unknown): error is AxiosError<ErrorResponse> {
  return axios.isAxiosError(error);
}
```

### 에러 서브클래싱하기

- `서브클래싱`: 기존 클래스를 확장하여 새로운 클래스를 만드는 과정을 말한다.
- 단순한 서버에러도 발생하지만 인증 정보 에러, 네트워크 에러, 타임아웃에러 등 다양한 에러가 발생하고, 이를 더욱 명시적으로 표시하기 위해 서브클래싱을 활용할 수 있다.
- 서브클래싱을 활용해 에러가 발생했을 때 코드상에서 어떤 에러인지를 바로 확인할 수 있고, 에러 인스턴스가 무엇인지에 따라 에러 처리 방식을 다르게 구현할 수 있다.
