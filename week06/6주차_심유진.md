# 06. 타입스크립트 컴파일

# 6.1 자바스크립트의 런타입과 타입스크립트의 컴파일

- **컴파일 타임** : 소스코드가 컴파일 과정을 거쳐 컴퓨터가 인식할 수 있는 기계어코드(바이트 코드)로 변환되어 실행할 수 있는 프로그램이 되는 과정
- **런타임** : 컴파일 과정을 마친 응용 프로그램이 사용자에 의해 실행되는 과정

## **6.1.1 자바스크립트 런타임**

대표적인 자바스크립트 런타임으로 크롬이나 사파리 같은 인터넷 브라우저와 Node.js 등이 있다.

자바스크립트 런타임은 다양한 구성 요소로 이루어져 있는데 주요 구성 요소로 자바스크립트 엔진, 웹 API, 콜백 큐, 이벤트 루프, 렌더 큐가 있다.

## **6.1.2 타입스크립트의 컴파일**

타입스크립트는 tsc라고 불리는 컴파일러를 통해 자바스크립트 코드로 변환되는데 사실 고수준 언어(타입스크립트)가 또 다른 고수준 언어(자바스크립트)로 변환되는 것이기 때문에 컴파일이 아닌 **트랜스파일**이라고 부르기도 한다.

또한 이러한 변환 과정은 소스코드를 다른 소스코드로 변환하는 것이기에 타입스크립트 컴파일러를 *소스 대 소스 컴파일러*라고 지칭하기도 한다.

타입스크립트 컴파일러는 소스코드를 해석하여 **AST**(최소 구문 트리)를 만들고 이후 타입확인을 거친 다음에 결과 코드를 생성한다.

## 6.1.3 타입스크립트의 컴파일

1. 타입스크립트 소스코드를 타입스크립트 AST로 만든다. (tsc)
2. 타입 검사기가 AST를 확인하여 타입을 확인한다.(tsc)
3. 타입스크립트 AST를 자바스크립트 소스로 변환한다. (tsc)
4. 자바스크립트 소스코드를 자바스크립트 SDT로 만든다.(런타임)
5. AST가 바이트 코드로 변환된다.(런타임)
6. 런타임에서 바이트 코드가 평가되어 프로그램이 실행된다. (런타임)

# 6.2 타입스크립트 컴파일러 동작

- 컴파일러의 주요 역할에 대해서 살펴볼 것이다

## 6.2.1 코드 검사기로서의 컴파일러

- 타입스크립트는 컴파일타임에 문법 에러와 타입 관련 에러를 모두 검출한다.

## 6.2.2 코드 변환기로서의 타입스크립트 컴파일러

- 최신 버전의 타입스크립트 자바스크립트 코드를 구버전의 자바스크립트로 트랜스파일한다.

# 6.3 타입스크립트 컴파일러의 구조

타입스크립트 컴파일러는 다섯 단계를 거쳐 타입 검사와 자바스크립트 소스 변환을 진행한다.

<img width="566" alt="Image" src="https://github.com/user-attachments/assets/8dadb98d-8b2e-4bbf-841d-7768498b1d8e" />

## 6.3.1 프로그램

타입스크립트 컴파일러는 tsc 명령어로 실행되며, 컴파일러는 `tsconfig.json`에 명시된 컴파일 옵션을 기반으로 컴파일을 수행한다.

먼저 전체적인 컴파일 과정을 관리하는 프로그램 객체(인스턴스)가 생성된다. 이 프로그램 객체는 컴파일할 타입스크립트 소스 파일과 소스 파일 내에서 임포트된 파일을 불러오는데, 가장 최초로 불러온 파일을 기준으로 컴파일 과정이 시작된다.

## 6.3.2 스캐너

스캐너는 타입스크립트 소스코드를 작은 단위로 나누어 의미 있는 토큰으로 변환하는 작업을 수행한다.

```tsx
const woowa = "bros";
```

위 코드는 스캐너에 의해 다음과 같이 분석된다.

<img width="449" alt="Image" src="https://github.com/user-attachments/assets/c104bdc5-430b-43b5-9904-4ef057de8a3d" />

## **6.3.3 파서(Parser)**

스캐너가 소스 파일을 토큰으로 나눠주면 파서는 그 토큰 정보를 이용하여 AST를 생성한다.

AST는 컴파일러가 동작하는 데 핵심 기반이 되는 자료 구조로, 소스코드의 구조를 트리 형태로 표현하다. AST의 최상위 노드는 타입스크립트 소스 파일이며, 최하위 노드는 파일의 끝 지점으로 구성된다.

스캐너가 어휘적 분석을 통해 토큰 단위로 소스코드를 나눈다면, 파서는 이렇게 생성된 토큰 목록을 활용하여 구문적 분석을 수행한다고 볼 수 있으며 이를 통해 코드의 실질적인 구조를 노드 단위의 트리 형태로 표현하는 것이다.

각각의 노드는 코드상의 위치, 구문 종류, 코드 내용과 같은 정보를 담고있다.

```tsx
function normalFunction() {
  console.log("normalFunction");
}

normalFunction();
```

<img width="677" alt="Image" src="https://github.com/user-attachments/assets/464774e6-b506-417e-a828-8fb440edf131" />

## 6.3.4 바인더

바인더의 주요 역할은 체커 단계에서 타입 검사를 할 수 있도록 기반을 마련하는 것이다. 바인더는 타입 검사를 위해 심볼이라는 데이터 구조를 생성한다. 심볼은 이전 단계의 AST에서 선언된 타입의 **`노드 정보를 저장`**한다.

```tsx
type SomeType = string | number;

interface SomeInterface {
  name: string;
  age?: number;
}

let foo: string = "LET";

const obj = {
  name: "이름",
  age: 10,
};
class MyClass {
  name;
  age;
  constructor(name: string, age?: number) {
    this.name = name;
    this.age = age ?? 0;
  }
}

const arrowFunction = () => {};

function normalFunction() {}

arrowFunction();

normalFunction();

const colin = new MyClass("colin");
```

![Image](https://github.com/user-attachments/assets/214bf858-5c7c-4896-b843-890fb33ec8ff)

## **6.3.5 체커(Checker)와 이미터(Emitter)**

**체커(Checker)**

체커는 파서가 생성한 AST와 바인더가 생성한 심볼을 활용하여 타입 검사를 수행한다. 이 단계에서 체커의 소스 크기는 파서의 소스 크기보다 매우 크며, 전체 컴파일 과정에서 타입 검사가 차지하는 비중이 크다는 것을 짐작할 수 있다.

체커의 주요 역할은 AST의 노드를 탐색하면서 심볼 정보를 불러와 주어진 소스 파일에 대해 타입 검사를 진행하는 것이다.

체커의 타입 검사는 다음 컴파일 단계인 이미터에서 실행된다. `checker.ts`의 `getDiagnostics()`함수를 사용해서 타입을 검증하고 타입 에러에 대한 정보를 보여줄 에러 메시지를 저장한다.

**이미터(Emitter)**

이미터는 타입스크립트 소스를 자바스크립트(js) 파일과 타입 선언 파일(d.ts)로 생성한다.

이미터는 타입스크립트 소스 파일을 변환하는 과정에서 개발자가 설정한 타입스크립트 설정 파일을 읽어오고, 체커를 통해 코드에 대한 타입 검증 정보를 가져온다. 그리고 `emitter.ts` 소스 파일 내부의 `emitFiles()`함수를 사용하여 타입스크립트 소스 변환을 진행한다.

지금까지의 내용을 정리하면 다음과 같다.

> 타입스크립트의 컴파일 과정

1. tsc 명령어를 실행하여 프로그램 객체가 컴파일 과정을 시작한다.
2. 스캐너는 소스 파일을 토큰 단위로 분리한다.
3. 파서는 토큰을 이용하여 AST를 생성한다.
4. 바인더는 AST의 각 노드에 대응하는 심볼을 생성한다. 심볼은 선언된 타입의 노드 정보를 담고 있다.
5. 체커는 AST를 탐색하면서 심볼 정보를 활용하여 타입 검사를 수행한다.
6. 타입 검사 결과 에러가 없다면 이미터를 사용해서 자바스크립트 소스 파일로 변환한다.

# 07. 비동기 호출

# 7.1 API 요청

## 7.1.1 fetch로 API 요청

fetch 함수를 사용하여 외부 데이터 베이스에 접근하여 사용자가 장바구니에 추가한 정보를 호출하는 코드는 다음과 같다.

```tsx
const CartBadge: React.FC = () => {
  const [cartCount, setCartCount] = useState(0);
  useEffcet(() => {
    fetch("카트정보 URL").then(({ cartItem }) => {
      setCartCount(cartItem.length);
    });
  }, []);
};
```

이때 만약 백엔드에서 기능을 변경해야해서 API를 수정할 경우 이미 컴포넌트 내부 깊숙이 자리 잡은 비동기 호출 코드는 변경 요구에 취약할 수 있다.

URL변경 뿐 아니라 모든 요청에 커스텀 헤더가 필요하다 같은 새로운 API 요청 정책이 추가 될 때마다 계속해서 비동기 호출을 수정해야하는 번거로움이 생긴다.

## 7.1.2 서비스 레이어 분리

여러 API 요청 정책이 추가되어 코드가 변경될 수 있다는 점을 감안하면 비동기 호출 코드는 컴포넌트 영역에서 분리되어 서비스레이어에서 처리되어야 한다.

앞의 코드 기준으로는 fetch함수를 호출하는 부분이 서비스 레이어로 이동하고 컴포넌트는 서비스 레이어의 비동기 함수를 호출하여 그 결과를 받아와 렌더링 하는 흐름이 된다.

하지만 단순히 fetch 함수를 분리한다고 API요청 정책이 추가되는 것을 해결하기는 어렵다.

## 7.1.3 Axios 활용하기

fetch는 내장 라이브러리이기 때문에 따로 임포트나 설치의 필요없이 바로 사용할 수 있다. 하지만 많은 기능을 사용하기 위해서는 직접 구현을해야한다. 이러한 번거로움 때문에 fetch대신 많이 쓰이는 것이 Axios 라이브러리다.

각 서버가 담당하는 부분이 다르거나 새로운 프로젝트의 일부로 포함될 때 기존에 사용하는 API Entry와는 다른 새로운 URL로 요청해야 하는 상황이 생길 수 있다.

이처럼 API Entry가 2개 이상인 경우에는 각 서버의 기본 URL을 호출하도록 2개 이상의 API 요청을 처리하는 인스턴스를 구성해야한다. 이후 다른 URL로 서비스 코드를 호출할 때는 각각의 apiRequester를 사용하면 된다.

```tsx
//기본적인 API 엔트리를 사용하는 Axios 인스턴스
const apiRequester: AxiosInstance = axios.create(defaultConfig);

//다른 API 엔트리인 "https://api.baemin.or/" 주소로 요청을 보내기 위한 Axios 인스턴스
const orderApiRequester: AxiosInstance = axiost.create({
  baseURL: "https://api.baemin.or/",
  ...defaultConfig,
});

//다른 API 엔트리인 "https://api.order/" 주소로 요청을 보내기 위한 Axios 인스턴스
const orderCartApiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.order/",
  ...defaultConfig,
});
```

## 7.1.4 Axios interceptors

각각의 requester는 서로 다른 역할을 담당하는 다른 서버이기 때문에 requester별로 커스텀 헤더를 설정해줘야하는 로직이 필요할 수 있다.

이때 axios에서 제공하는 interceptors기능을 사용하여 requester에 따라 비동기 호출 내용에 추가해서 처리할 수 있다. 또한 API에러를 처리할 때 하나의 에러 객체로 묶어서 처리할 수도 있다.

이와 달리 요청 옵션에 따라 다른 인터셉터를 만들기 위해 빌더 패턴을 추가하여 APIBulder같은 클래스 형태로 구성하기도 한다.

- **빌더패턴**: 객체생성을 더 편리하고 가독성 있게 만들기 위한 디자인 패턴 중 하나, 주로 복잡한 객체의 생성을 단순화 하고 객체 생성 과정을 분리하여 객체를 조립하는 방법을 제공한다.

## **7.1.5 API 응답 타입 지정**

같은 서버에서 오는 응답의 형태는 대체로 통일되어있다. 그래서 앞서 소개한 API의 응답 값은 하나의 Response 타입으로 묶일 수 있다.

```tsx
interface Response<T> {
  data: T;
  status: string;
  serverDateTime: string;
  errorCode?: string;
  errorMessage?: string;
}

// 카트 정보를 가져오기 위한 API 요청
// AxiosPromise를 반환하며, 해당 Promise의 제네릭 타입은 Response<FetchCartResponse>로 정의
// FetchCartResponse는 서버에서 받아온 카트 정보에 대한 타입
const fetchCart = (): AxiosPromise<Response<FetchCartResponse>> => {
  apiRequester.get < Response < FetchCartResponse >> "cart";
};

// 카트에 데이터를 추가하거나 업데이트하기 위한 API 요청
// AxiosPromise를 반환하며, 해당 Promise의 제네릭 타입은 Response<PostCartResponse>로 정의
// PostCartResponse는 서버에서 받아온 카트에 대한 업데이트 결과에 대한 타입
const postCart = (
  postCartRequest: PostCartRequest
): AxiosPromise<Response<PostCartResponse>> => {
  apiRequester.post<Response<PostCartResponse>>("cart", postCartRequest);
};
```

하지만 서버에서 오는 응답을 통일할 때 주의점이 있다. Response의 타입을 apiRequester내에서 처리하고 싶은 생각이 들 수 있는데 이렇게 하면 update나 create같이 응답이 없을 수 잇는 API를 처리하기 까다로워진다.

```tsx
const updateCart = (
  updateCartRequest
): AxiosPromise<Response<FetchCartResponse>> => apiRequester.get<null>("cart");
```

따라서 Response 타입은 apiRequester가 모르게 관리되어야 한다.

**뷰모델 사용**

프로젝트 초기에는 서버 스펙이 자주 바뀐다. 이때 뷰모델을 사용하여 **API 변경에 따른 범위**를 한정해주는 것이 좋다.

좋은 컴포넌트는 변경될 이유가 하나뿐인 컴포넌트라고 말한다. API 응답으로 인해 수정해야할 컴포넌트가 API 1개당 하나라면 좋겟지만 API를 사용하는 기존 컴포넌트도 수정되어야 한다. 이러한 문제를 해결하기 위한 방법으로 뷰모델을 도입할 수 있다.

```tsx
interface JobListItemResponse {
  name: string;
}

interface JobListResponse {
  jobItems: JobListItemResponse[];
}

class JobList {
  readonly totalItemCount: number;
  readonly items: JobListItemResponse[];

  constructor({ jobItems }: JobListResponse) {
    this.totalItemCount = jobiItems.length;
    this.items = jouItems;
  }
}

const fetchJobList = async (
  filter?: ListFetchFilter
): Promise<JobListResponse> => {
  const { data } = await api
    .params({ ...filter })
    .get("/apis/get-list-summaries")
    .call<Response<JobListResponse>>();

  return new JobList(data);
};
```

# **7.2 API 상태관리하기**

## **7.2.1 상태관리 라이브러리에서 호출하기**

상태관리 라이브러리의 비동기 함수들은 서비스 코드를 사용하여 비동기 상태를 변화시킬 수 있는 함수를 제공한다

서비스코드: 액션생성자, 비동기작업을 수행하고 애플리케이션의 상태를 업데이트하는 역할

컴포넌트는 이러한 함수르 사용하여 상태를 구독하며, 상태가 변경될 때 컴포넌트를 다시 렌더링 하는 방식으로 동작한다.

## **7.2.3 훅으로 호출하기**

react-query나 useSwr 같은 훅을 사용한 방법은 훅을 사용하여 비동기 함수를 호출하고 상태관리 라이브러리에서 발생한 의도치 않은 상태 변경을 방지하는 데 큰 도움이 된다.

# **7.3 API 에러 핸들링**

비동기 API호출에서는 상태 코드에 따라 401,404,500,cors에러 등 다양한 에러가 발생할 수 있다.

이때 에러 상황에 대한 명시적인 코드 작성시 유지보수가 용이해지고 사용자에게도 구체적인 에러 상황을 전달할 수 있다.

## **7.3.1 타입 가드 활용하기**

Axios 라이브러리에서는 Axios 에러에 대해 isAxiosError라는 타입 가드를 제공하고 있다. 이때 서버 에러임을 명확하게 표시하고 서버에서 내려주는 에러 응답 객체에 대해서도 구체적으로정의함으로써 에러 객체가 어떤 속성을 가졌는지 파악할 수 있다.

```tsx
interface ErrorResponse {
  status: string;
  serverDateTime: string;
  errorCode: string;
  errorMessage: string;
}
```

## **7.3.2 에러 서브 클래싱 하기**

요청을 처리할 때 단순 서버 에러 뿐만 아니라 인증, 네트워크, 타임아웃 등 다양한 에러가 발생할 수 있다. 이를 더욱 명시적으로 표시하기 위해 서브클래싱을 활용할 수 있다.

서브클래싱 : 기존 클래스를 확장하여 새로운 하위 클래스를 만드는 과정. 새로운 클래스는 상위 클래스의 모든 속성과 메서드를 상속받아 사용할 수 있고 추가적인 속성과 메서드를 정의할 수 있다.

```tsx
// 주문 내역 가져오기
const fetchOrderHistory = async () => {
  try {
    const response = await apiRequester.get("/order-history");
    console.log("Order history data received:", response.data);
  } catch (error: unknown) {
    if (error instanceof AxiosError) {
      if (error.response) {
        const { status, data } = error.response;
        const { errorCode, errorMessage } = data;

        if (status === 401) {
          // UnauthorizedError
          throw new UnauthorizedError(errorMessage, error.response);
        } else {
          // OrderHttpError
          throw new OrderHttpError(errorMessage, error.response);
        }
      } else if (error.request) {
        // 요청 전송 후 응답이 없는 경우
        throw new NetworkError("No response received");
      } else {
        // 요청 전송 전에 에러가 발생한 경우
        throw new NetworkError("Request error");
      }
    } else {
      // Axios 에러가 아닌 경우
      throw error;
    }
  }
};
```

## **7.3.3 인터셉터를 활용한 에러 처리**

axios같은 페칭 라이브러리는 인터셉터 기능을 제공한다. 이를 사용하면 HTTP에러에 일관된 로직을 적용할 수 있다.

`axios.interceptors.response.use():` `use` 함수에는 두 개의 콜백 함수를 매개변수로 전달할 수 있음

- 첫 번째 함수 (onFulfilled): 이 함수는 성공적으로 응답을 받았을 때 호출
- 두 번째 함수 (onRejected): 이 함수는 응답이 실패했을 때, 즉 HTTP 요청이 실패하거나 서버에서 에러 응답을 반환했을 때 호출

```tsx
const httpErrorHandler = (
  error: AxiosError<ErrorResponse> | Error
): Promise<Error> => {
  (error) => {
    if (error.response && error.response.stauts === "401") {
      window.location.href = `/login`;
    }
    return Promise.reject(error);
  };
};

orderApiRequester.interceptors.response.use(
  // 응답 성공시
  (response: AxiosResponse) => response,
  // 응답 실패시 httpErrorHandler() 호출
  httpErrorHandler
);
```

## 7.3.4 **에러 바운더리를 활용한 에러 처리**

에러 바운더리는 리액트 컴포넌트트리에서 에러가 발생할 때 공통으로 에러를 처리하는 리액트의 컴포넌트이다.

에러 바운더리를 사용하면 해당 컴포넌트의 하위에 있는 컴포넌트에서 발생한 에러를 캐치하고 해당 에러를 가장 가까운 부모 에러 바운더리에서 처리할 수 있다.

에러 바운더리는 에러가 발생한 컴포넌트 대신에 에러 처리를 하거나 예상치 못한 에러를 공통 처리할 때 사용할 수 있다.

## **7.3.5 react-query를 활용한 에러 처리**

react-query나 swr과 같은 데이터 페칭 라이브러리를 사용하면 요청에 대한 상태를 반환해주기 때문에 요청 상태를 확인하기 쉽다.
