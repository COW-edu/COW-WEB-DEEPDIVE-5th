# 3장 고급 타입

## 타입 스크립트의 독자적 타입 시스템

타입스크립트는 JS 에서 제시되지 않은 독자적인 타입 시스템을 가지고 있다.

하지만 타입스크립트의 타입 시스템이 내포하고 있는 개념은 모두 JS 에 기인한 것이기에 이를 인지하고 독자적 타입을 알아보자.

### any 타입

any 타입은 자바스크립트에 존재하는 모든 값을 오류 없이 받을 수 있다.

즉 타입을 명시하지 않은 것과 동일한 효과를 나타낸다

```jsx
let state: any;
// 객체 할당
state = { value: 0 };
// 숫자 할당
state = 100;
//문자열 할당
state = "hello world";
// 중첩구조로 들어가 함수 할당
state.inner = () => console.log("any type");
```

**any를 지양해야 하는 이유**

- 타입스크립트를 사용한 정적 타이핑의 의미를 무색하게 만든다
- 기존 JS를 사용하는 것과 다름이 없다
- 런타임시 에러가 발생할 수 있다.

하지만 아래의 3가지 대표적인 사례는 any 타입을 어쩔 수 없이 사용해야 할 때가 있다

1. **개별 단계에서 임시로 값을 지정해야 할 때**

   <aside>
   💡

   매우 복잡한 구성 요소로 이루어진 개발 과정에서 추후 값이 변경될 여지가 있거나 타입에 대한 확정이 이루어지지 않을 경우.

   </aside>

2. **어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때**

   <aside>
   💡

   API 요청 및 응답처리, 콜백 함수 전달 등 어떤 값의 타입을 명확하게 정하기 힘든 경우 any타입을 사용할 수 있다.

   </aside>

3. **값을 예측할 수 없을 때 암묵적으로 사용**

   <aside>
   💡

   외부 라이브러리나 웹 API요청에 의해 다양한 값을 반환하는 API가 존재할 수 있다. 브라우저의 Fetch API의 일부 메서는 요청 이후의 응답을 특정 포맷으로 파싱하는데 이대 반환 타입이 any로 매핑되어 있는 것을 확인 할 수 있다.

   </aside>

하지만 그래도 any 타입은 개발자에게 편의성과 확장성을 제공하기도 하지만 지양해야 한다.

### unknown 타입

unknown 타입은 any 타입과 유사하게 모든 타입의 값이 할당 가능하다.

다만 any는 다른 타입으로 선언된 변수에 any 타입을 할당할 수 있지만 unknown은 any 타입을 제외한 다른 타입으로 선언된 변수에는 unknown 타입 값 할당이 불가능하다

```jsx
let anyData: any;

anyData = "string";
anyData = () => {
  console.log("function");
};
anyData = 100;

let anyData2: string = anyData; // 할당 가능
```

```jsx
let unknownData: unknown;

unknownData = 100;
unknownData = "string";
unknownData = () => {
  console.log("function");
};

let unknownData3: any = unknownData; // 할당 가능
let unknownData2: string = unknownData; // "'unknown' 형식은 'string' 형식에 할당할 수 없습니다." 에러 발생
```

**unknown 타입이 등장한 이유**

- 기존 타입 시스템에서 부족한 부분을 보완하기 등장
- unknow 타입은 어떤 타입이 할당되었는지 알 수 없음을 나타내기에 unknown 타입으로 선언된 변수는 값을 가져오거나 내부 속성에 접근이 불가능하다
- unknown 타입으로 할당된 변수는 어떤 값이든 올 수 있음을 의미하는 동시에 개발자에게 엄격한 타입 검사를 강제하는 의도를 가지고 있다
- any 타입과 유사하지만 타입 검사를 강제하고 타입이 식별된 후에 사용이 가능하다
- 즉 any 타입 대신 unknown 타입으로 대체해서 사용하는 방식이 권장 됨

## void 타입

함수가 어떤 값을 반환하지 않을 경우 void를 지정하여 사용한다

```jsx
function showModal(type: ModalType): void {
  // ~~~ 함수 내용
}
```

일반적으로 함수 자체를 다른 함수의 인자로 전달하는 경우가 아니라면 void 타입을 명시적으로 작성하는 경우는 드물다.

## never 타입

never 타입도 void 와 마찬가지로 타입의 값을 반환할 수 없는 타입을 말한다

보통 에러를 던지는 경우 or 무한히 함수가 실행되는 경우에 사용된다.

```jsx
function generateError(res: Response): never {
  throw new Error(res.getMessage());
}

function checkStatus(): never {
  while (true) {
    //.....
  }
}
```

## Array 타입

타입스크립트에서는 배열의 크기를 강제하지는 않지만 정적 타입의 특성을 살려 명시적인 타입을 선언함으로서 해당 타입의 원소를 관리하는 '것을 강제한다.

```tsx
const array1: number[] = [1, 2, 3];
const array2: Array<number> = [1, 2, 3];
const array2: Array<number | string> = [1, 2, 3, "엥"];
// 두 가지 방식 모두 동일한 방식으로 팀의 컨벤션의 따름
```

### 튜플

튜플은 배열의 기능에 길이 제한까지 추가된 타입 시스템이다

대괄호와 타입 시스템을 사용하여 선언할 수 있으며 대괄호 안에 선언하는 타입의 개수가 튜플이 가질 수 있는 원소의 개수를 나타낸다

```tsx
let tuple: [number] = [1];
tuple = [1, 2]; // 불가능
```

튜플의 경우 각 컨벤션을 잘 지키고 각 배열 원소의 명확한 의미와 쓰임을 보장할 때 더욱 안전하게 사용할 수 있는 타입이다.

## enum 타입

열거형이라고 부르며 일종의 구조체를 만드는 타입 시스템이다.

enum 타입은 주로 문자열 상수를 생성하는데 사용된다.

```tsx
enum ProgrammingLanguage {
  Typescript, // 0
  Javascript, // 1
  Java, // 2
  Python, // 3
  Rust, // 4
}

// ProgrammingLanguage의 멤버로 접근
ProgrammingLanguage.Typescript; // 0
ProgrammingLanguage.Javascript; // 1
ProgrammingLanguage.Python; // 3
ProgrammingLanguage["Rust"]; // 4

// 역방향 접근도 가능
ProgrammingLanguage[2]; // Java
```

### enum 사용 시 주의 사항

1. 의도하지 않은 값의 할당이나 접근이 가능하다

   ```tsx
   ProgrammingLanguage[200]; // undefined를 출력하지만 컴파일 단계에서 별다른 에러 출력 x
   ```

   위의 예시와 같이 할당된 값을 넘어서는 범위에 역방향으로 접근이 가능하지만 에러가 발생하지 않는다. 이러한 접근을 방지하기 위해 `const enum` 으로 열거형을 선언하는 방법이 있다.

2. 불필요한 번들 크기 증가

   열거형은 타입공간과 값 공간 모두에 사용된다. 열거형은 TS → JS로 변환될 때 즉시 실행함수로 변경

   이때 즉시 실행 함수로 변환된 값을 사용하지 않는 코드로 인식하지 못하는 경우가 발생하여 불필요한 코드의 크기가 증가하는 결과를 초래할 수 있다.

## 타입 조합

### 교차 타입(Intersection)

교차 타입을 통해 여러 가지 타입을 결합하여 하나의 단일 타입으로 만들 수 있다

```tsx
type ProductItem = {
	id: number;
	name:string;
	...
}

type ProductWithDiscount = ProductItem & {discountAmount: number}
```

### 유니온 타입(Union)

유니온 타입은 타입 A 또는 타입 B 중 하나가 될 수 있는 타입을 말하며 |을 사용하여 표기한다.

```tsx
type CartItem = {
  id: number;
  name: string;
  type: string;
  imageUrl: string;
};

type PromotionEventItem = ProductItem | CartItem;
```

### 인덱스 시그니처

인덱스 시그니처는 특정 타입의 속성 이름은 알 수 없지만 속성값의 타입을 알고 있을 때 사용하는 문법이다.

```tsx
interface IndexSignature {
  [key: string]: number;
}
```

### 인덱스드 엑세스 타입

다른 타입의 특정 속성이 가지는 타입을 조회하기 위해 사용된다.

```tsx
const PromotionList = [
  { type: "product", name: "laptop" },
  { type: "product", name: "keyboard" },
  { type: "card", name: "SH" },
];

type ElementOf<T> = (typeof T)[number];
// type PromotionItemType = {type:string; name:string}
type PromotionItemType = ElementOf<PromotionList>;
```

### 맵드 타입

맵드 타입은 다른 타입을 기반으로 한 타입을 선언할 때 사용하는 문법이다. 인덱스 시그니처 문법과 함께 사용하여 반복적 타입 선언을 줄일 수 있다.

```tsx
type Example = {
  a: number;
  b: string;
  c: boolean;
};

type Subset<T> = {
  [K in keyof T]?: T[K];
};

const aExample: Subset<Example> = { a: 100 };
const bExample: Subset<Example> = { b: "string" };
const cExample: Subset<Example> = { c: true };
```

### 템플릿 리터럴 타입

자바스크립트의 템플릿 리터럴 문자열을 사용하여 문자열 리터럴 타입을 선언할 수 있는 문법이다.

```tsx
type Status = "before" | "in progress" | "after";

type TestStatus = `Test-${Status}`;
// "Test-before" | "Test-in progress" | "Test-after";
```

## 제네릭 타입

제네릭은 타입을 마치 함수의 매겨변수처럼 사용할 수 있게 해주는 기능이다

이를 통해 다양한 타입에 대해 재사용 가능한 컴포넌트를 만들 수 있다.

타입을 인자로 받는 것을 생각하면 된다

```tsx
// 제네릭 없이 작성한 경우 - 타입별로 함수를 만들어야 함
function getFirstNumber(arr: number[]): number | undefined {
  return arr[0];
}

function getFirstString(arr: string[]): string | undefined {
  return arr[0];
}

// 제네릭을 사용한 경우 - 하나의 함수로 여러 타입 처리 가능
function getFirst<T>(arr: T[]): T | undefined {
  return arr[0];
}

// 사용 예시
const numbers = [1, 2, 3, 4, 5];
const strings = ["a", "b", "c"];

// 타입 추론을 통해 자동으로 타입 결정
const firstNumber = getFirst(numbers); // number | undefined 타입
const firstString = getFirst(strings); // string | undefined 타입

// 명시적으로 타입 지정도 가능
const firstExplicitNumber = getFirst<number>(numbers); // number | undefined 타입
```

### 함수의 제네릭

어떤 함수의 매개변수나 반환 값에 다양한 타입을 넣고 싶을 때 제네릭을 사용할 수 있다.

```tsx
// 제네릭을 사용한 filter 함수
function filter<T>(array: T[], predicate: (item: T) => boolean): T[] {
  const result: T[] = [];

  for (const item of array) {
    if (predicate(item)) {
      result.push(item);
    }
  }

  return result;
}

// 숫자 배열에 적용
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = filter(numbers, (num) => num % 2 === 0);
console.log(evenNumbers); // [2, 4, 6, 8, 10]

// 문자열 배열에 적용
const fruits = ["apple", "banana", "grape", "orange", "kiwi"];
const longFruits = filter(fruits, (fruit) => fruit.length > 5);
console.log(longFruits); // ['banana', 'orange']

// 객체 배열에 적용
interface Person {
  name: string;
  age: number;
}

const people: Person[] = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 17 },
  { name: "Charlie", age: 30 },
  { name: "David", age: 15 },
];

const adults = filter(people, (person) => person.age >= 18);
console.log(adults); // [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 30 }]
```

### 호출 시그니처의 제네릭

타입스크립트의 함수 타입 문법, 함수의 매개변수와 반환 타입을 미리 선언하는 것

```tsx
export type UserRequestHookType = <RequestData = void, ResponseData = void>(
  baseURL?: string | Headers,
  defaultHeader?: Headers
) => [RequestStatus, Requester<RequestData, ResponseData>];
```

위 코드는 호출 시그니처의 제네릭 활용 예시로 함수를 선언한 뒤 타입을 UserRequestHookType으로 지정하여 함수를 호출할 때 제네릭으로 구체적 타입으로 명시가 가능하다

```tsx
const defaultHeader: Headers = { header: "header" };

userRequestFunction<string, number>("baseURL", defaultHeader);
```

### 제네릭 클래스

제네릭 클래스는 외부에서 입력된 타입을 클래스 내부에서 적용할 수 있는 클래스다

```tsx
class Box<T> {
  private content: T;

  constructor(value: T) {
    this.content = value;
  }

  getValue(): T {
    return this.content;
  }

  setValue(value: T): void {
    this.content = value;
  }
}

// 문자열 박스 생성
const stringBox = new Box<string>("안녕하세요");
console.log(stringBox.getValue()); // "안녕하세요" 출력
stringBox.setValue("반갑습니다");
console.log(stringBox.getValue()); // "반갑습니다" 출력

// 숫자 박스 생성
const numberBox = new Box<number>(123);
console.log(numberBox.getValue()); // 123 출력
numberBox.setValue(456);
console.log(numberBox.getValue()); // 456 출력
```

### 제한된 제네릭

타입스크립트에서 제한된 제네릭은 타입 매개변수에 대한 제약 조건을 설정하는 기능을 말한다.

```tsx
type Student = {
  name: string;
  age: number;
};

function printStudent<T extends Student>(obj: T, key: keyof T): void {
  console.log(obj[key]);
}
```

printStudent의 타입 매개변수 T는 Student라는 타입으로 제약 조건이 설정되어 있다. 이처럼 타입 매개변수가 특정 타입에 묶여 있을 때 해당 키를 바운드 타입 매개변수라 부른다.

### 확장된 제네릭

제네릭 타입은 여러 타입을 상속 받을 수 있으며 타입 매개변수를 여러 개 둘 수 있다.

```tsx
<Key extends string> // 제네릭의 유연성을 잃어버린다
<Key extends string|number>  // 유니온 타입으로 유연성 챙기기
```
