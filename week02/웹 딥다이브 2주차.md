# 웹 딥다이브 2주차

날짜: 2025년 4월 3일

## 타입스크립트 타입 계층 구조

![image.png](%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%83%E1%85%B5%E1%86%B8%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%201ca6f972e5ea805e88fee2bc949e2a12/image.png)

# 고급 타입

## ANY 타입

모든 자료형에 대해서 사용될 수 있는 타입 자바스크립트에 기인한 시스템이다. 그로인해 자바스크립트에서 사용되는 모든 타입에 대해서 할당이 가능하다.

그로인해 Any 타입을 쓴다면 특수한 경우를 제외하고는 사용을 지양하는것이 좋다 왜냐하면 이럴거면 타입스크립트 쓰는 이유가 없으니..

### any타입을 사용하는경우

- 개발 단계에서 임의로 값을 지정해야 하는 경우
    - 추후 값이 변경될 가능성이 있거나 아직 구체적으로 어떤 값이 들어오지 못하는경우 
    ex) 아이디값으로 문자열을 제공하는데 숫자열을 받아야 하는 경우로 수정해야할 때
- 어떤 값을 받아올지 모르는 경우
    - 콜백 함수를 전달해서 어떤 데이터를 받아올지 명확하게 알 수 없을 때
    - 외부 라이브러리를 사용할 때
- 값을 예측할 수 없을 때 암묵적으로 사용
    - 외부 api 중 요청에 따라 다양한 값을 반환하는 api가 있을 때 특정한 타입을 하나로 정해두면 에러가 발생하기 때문이다.

---

## unknown 타입

any 타입과 비슷하지만 any를 제외한 다른 타입에는 할당이 불가능한 타입

그 둘의 차이는 아래 표와 같다.

| any | unknown |
| --- | --- |
| 어떤 타입이든 할당 가능 | 어떤 타입이든 할당 가능 |
| never 제외 전부다 할당가능 | any외 다른 타입에 할당 불가능 |

### unknown 타입을 사용하는 경우

### void 타입

내가 알고 있는 void 타입은 자바에서 클래스를 만들고 함수형으로 무언가를 만들었을 때 봤었던 기억이 있다. 이번에는 타입스크립트에서의 void에 대해서 알아보자.

타입스크립트에서는 보이드 타입을 어느 함수에 대해서 아무것도 반환하지 않을 경우, 콘솔에 로그를 출력하거나 다른 함수를 실행하는 경우에 void 타입을 설명하고 있다 

자바스크립트는 기본적으로 함수가 아무런 값도 반환하지 않을 때 undefined 를 반환하지만 이것이 void 타입과 같다고 생각하면 안된다 왜냐면 void 타입에는 undefined, null 값을 할당할 수 있기 때문이다.

### NEVER 타입

never 타입은 any타입과 반대되는 개념이라고 생각하면 이해하기가 쉽다.
무슨 의미냐면 any를 포함한 그 어느타입에도 할당이 불가능하다는 의미이다.
그리고 never 타입은 값을 변환할 수 없는 타입이다. 다시 말하지만 변환할 수 없다 변환을 안하는게 아니다. 

**타입을 변환할 수 없을 때** 

1. 에러를 던지는 경우
throw 키워드를 사용해서 에러를 발생시켰을 때 함수가 마지막에 에러를 던지는 행위를 했을 때 그 타입이 never이다.
2. 무한히 함수가 실행되는 경우

---

### Array 타입

배열 타입은 자바스크립트에서의 의미와 타입스크립트 에서의 의미가 다르다

| 자바스크립트 | 타입스크립트 |
| --- | --- |
| 객체에 속하는 타입(배열을 단독의 자료형으로 분류 안함) | 배열 자체를 하나의 타입으로 다루고 하나의 자료형으로 다룸 |
| 어떤 값이 들어와도 상관없음 | 타입으로 명시한 값들만 들어올 수 있고 순서도 상관있음 |

타입스크립트에서의 배열 시스템

array 키워드 혹은 [] 사용 이때의 타입은 튜플형이다

```tsx
const arr : number[] = [1,2,3]; //배열선언

const arr2 : Array<number> = [1,2,3]; //배열선언
```

자바스크립트의 동작은 배열 원소의 타입을 구분 안해서 다양한 타입의 원소가 들어올 수 있음 타입스크립트에서도 이렇게 사용하기 위해서 “유니온 타입” 이라는 것을 사용함

```tsx
const arr : number[] | string[] = [1,"two"]; //배열선언

const arr2 : Array<number | string> = [1,"two"]; //배열선언

const arr3 : (number | string)[] = [1,"two"]; //이렇게도 가능

arr3 = [1,"이",3] //이렇게 하면 오류발생한다 
```

자바스크립트에서는 배열 타입의 명시 및 배열의 길이제한이 불가능하다 하지만 타입스크립트는 튜플을 이용해 타입명시와 배열의 길이 제한까지 가능하다. 

이 유니온 타입을 통해서 얻을 수 있는 이점은 무엇일까?
바로 원소의 개수와 타입을 보장하여 다른 데이터들이 섞이는 것을 방지한다.

**만약 순서에 의존을 하고싶지 않다면 어떻게 해야할까?**

정답은 스프레드 연산자이다!
스프레드 연산자를 사용해서 튜플과 배열의 성질을 섞어서 사용해도 좋다. 

**만약 데이터를 가져왔는데 값이 없을 경우 오류를 발생시키지 않으려면?**

옵셔널 프로퍼티를 사용하면 됩니다! 
데이터가 필수적으로 존재하지 않아도 문제가 없고 할당을 안해도 괜찮다! 이를 통해서 더 유연하게 데이터를 사용할 수 있다

```tsx
const justTuple : [number, number] = [1,2,3]; //오류발생

const optionalTuple2 : [number, number, number?] = [1,2]; //오류발생안함 값이 없어도 괜찮음
```

## Enum 타입

이넘 타입은 타입스크립트에서 지원하는 특별한 타입이다.
 이넘은 자바스크립트의 객체와 비슷한 개념이다.
 나는 이넘 타입을 타입스크립트에서 처음 봤지만 다른 언어에서도 사용되는 개념이라고 한다.

 일종의 구조체를 만드는 개념이고 하나 하나가 배열같이 인덱스번호를 같는 개념으로 이해했다. 그이유는 이넘 타입은 타입스크립트가 알아서 맴버의 값을 추론하기 때문이다. 타입스크립트는 0부터 1씩 늘리며 값을 추론하기 때문이다

```tsx
enum coffee {
	bean //0
	grinder
	cup
	water //3
}

coffee.0 = bean //이렇게 값 나와요
coffee[0] = bean //이런식으로도 사용이 가능함

//하지만 놀랍게도 추론하는 방식 말고도 값을 선언해서 표기도 가능하다!
enum coffee {
	bean = 'colombia'
	grinder = 'auto'
	cup = 'glass'
	water = 'iced'
}

```

이로 인해서 이넘타입은 주로 문자열 상수를 생성하는데 사용된다고 말한다. 

이런식으로 작성을 한다면 코드의 가독성을 높일 수 있다. 또한 하나하나씩 타입을 지정을 안해도 타입이 이미 지정돼있어서 편하게 사용도 가능하다 → 쓸모없는 타이핑을 안할 수 있다.

주의점으로는 숫자로만 이루어지거나, 언어가 알아서 추론한 열거형은 안정성이 떨어지기 때문에 숫자열보다는 문자열로 사용하는 경우 안정성이 높기 때문에 문자열을 추천한다. + 타입스크립트에서 자바스크립트로 인식되는 과정에서 인식이 불가능할 경우가 있어 const enum을 통해서 유니온 타입으로 열거형과 동일한 효과를 얻는 방법도 있다

# 타입 조합

## 교차 타입

여러가지 타입을 결합하여 하나의 타입으로 만든것을 의미한다. 나는 이런 방법을 &와 같은 방식이라고 이해했다

예시는 다음과 같다

```tsx
type Customer = {
	name : stirng;
	custId : number;
	address : string;
	id : number;
}

type adimnCustomer = Customer & {isAdimn : boolean};
```

## 유니온 타입

유니온 타입은 교차 타입과 다르게 a, b 타입이 있을 때 둘 중 하나만 만족해도 괜찮은 경우다. 나는 유니온 타입을 | (or) 와 같다고 이해했다. 하지만 주의할 부분은 두개가 유니온 된 상태에서 a에만 있고 b에는 없는 객체를 찾으려고 하면 오류가 발생한다!

## 인덱스 시그니처

특정 타입의 속성 이름은 알 수 없지만 속성값의 타입을 알고 있을 때 사용하는 문법이다.

사용법은 인터페이스 내부에 [Key : k] : T 이런 모양으로 사용되고 해당 속성의 키는 모두 k타입이고 해당 속성값은 모두 T 타입을 가져야 한다는 의미이다.

```tsx
interface indexSig {
	[key : number]:string;
}

//추가적인 속성을 추가하는 경우
interface indexSig2 {
	[key : number]:string | number;
	length : number; 
	isValid : boolean; //여기서 에러가 발생함 그 이유는 키값이 넘버일 때 스트링 또는 넘버타입만 올 수 있기 때문	
	name : string;

}
```

인덱스 시그니처를 선언하면서 다른 속성을 추가적으로 명시가 가능한데 주의를 해야하는 부분은  추가로 명시된 속성이 인덱스 시그니처에 포함되는 타입이어야함. 

## 인덱스드 엑세스 타입

다른 타입의 특정 속성이 가지는 타입을 조회하기 위해서 사용됨 타입을 정의한 A 라는 객체에 a1 이라는 속성이 어떤 타입인지 궁금하다면 

객체이름[속성이름] ;  이렇게 하면 값이 나온다.

 이 때 도출되는 타입또한 타입이므로 유니온타입, keyof, 타입 별칭 등 표현을 사용할 수 있다

```tsx
type example = {
	a : number;
	b : string;
	c : boolean;
}

type indexedAccess = example["a"] //넘버가 나옴
type indexedAccess2 = example["a"|"b"] //넘버 | 스트링 나옴
type indexedAccess3 = example[keyof example]// 넘버 | 스트링 | 불린 다나옴
```

 즉 타입오브를 사용하거나 키오브를 사용했을 때 배열요소의 타입을 알 수 있게 해준다.

## mapped타입

자바스크립트의 map함수 처럼 어느 배열을 받아서 새로운 배열을 만드는것 처럼 다른 타입을 기반으로 새로운 타입을  선언하는 것이다. 

인덱스 시그니처를 사용해서 효율적으로 타입선언을 줄일 수 있다

```tsx
type example = {
	a : number;
	b : string;
	c : boolean;
}

type subType<T> = {
	[k in keyof T]? : T[K];
}
const aExam : subType<example> = {a : 3};
const bExam : subType<example> = {b : "3"};
const cExam : subType<example> = {a : 3, c : true};
const aExam : subType<example> = {a : "3"}; //만약 이렇다면 오류발생
```

주의할점 : 맵드 타입에서는 매핑을 할 때 readonly, ? 라는 수식어를 사용하는데 리드온리는 읽기전용으로 만들고 싶을때 사용하고 ? 는 선택적 파라미터로 만들때 쓰인다. 이것은 앞에 더하는것도 가능하고 제거하는것도 가능하다. 

```tsx
type User = {
  id: number;
  name: string;
  email: string;
};

type StringifiedUser = {
  [K in keyof User]: string;
};

//이렇게 한다면 유저에 있는 값들은 타입이 스트링으로 모두 변경됨
```

즉 새롭게 만들 필요가 없이 이 타입으로 여러가지 타입을 만들 수 있는거다 그렇다고 새로운 요소를 추가해야한다면 새롭게 만드는게 나을지 아님 저기에 추가해서 변형하는게 나을지 궁금하네요

## 템플릿 리터럴 타입

템플릿 리터럴 문자열을 사용해서 문자열 리터럴 타입을 선언할 수 있는 문법이라고 책에서 설명한다.

말로 들으면 좀 어렵지만 간단하게 말하면 ``써서 처리할 수 있다는 뜻이다.

```tsx
type user = {
	|"id"
	|"name"
	|"age"
}

type userName = `user-${user}`;
//이런식으로 백틱 써서 유니온 타입을 표현할 수 있다는 의미이다
```

(실제로 코드를 짤때 어떻게 활용되는지 궁금합니다.)

# 제네릭

정의는 특징이 없지만 일반적인것을 의미한다. 

개념적으로는 정적언어에서 타입의 재사용성을 올리기 위해서 사용하는 문법이다, 타입스크립트에는 일반화 된 데이터 라고 설명한다.

이는 타입스크립트 에서도 이용되는데 어떻게 사용되냐면 내부적으로 타입을 정해두는것이 아닌 타입변수를 사용해서 타입변수를 비워두고 실제로 값을 사용할 때 필요한 타입을 지정해서 사용하는 방식이다.

간단하게 말하자면 클래스처럼 틀 만들어서 필요한 타입을 넣어서 쓰는것이다.

장점 : 하나 하나 정의할 필요가 사라져 재사용성이 크게 올라간다. 

```tsx
interface GenericIdentityFn {
    (arg: T): T; //T는 타입 매개변수
}

function identity(arg: T): T { //파라미터 타입
    return arg;
}
//더 심플한 버전
const identity<number>(10) // 10 나옴
//좀 어려운 버전
const myIdentity: GenericIdentityFn = identity;
console.log(myIdentity(10)); // 10
```

```tsx
type ApiResponse<T> = {
  message: string;
  body: T;
};

type User = {
  id: number;
  name: string;
};

const userResponse: ApiResponse<User> = {
  message: "ok",
  body: {
    id: 1,
    name: "Alice",
  },
};

```

보통 어떻게 타입 변수명은 T(type), E(element), K(key), V(value) 등 한 글자로 된 이름을 사용한다고 설명한다.

### any 와 제네릭 차이점

any는 모든 타입이 들어갈 수 있다 제네릭도 마찬가지다 하지만 가장 큰 둘의 차이점은 무엇일까?

배열을 넣었을 때 알 수 있는데 any에서는 배열에 모든 타입이 다 들어가도 상관없다 무슨 의미냐면 어떤 타입이던지 신경안쓰고 들어오는건데 제네릭에서는 모든 타입에 대한 검사가 이루어지기 때문에 타입에 대한 보장이 이루어진다

| any | 제네릭 |
| --- | --- |
| 어떤 타입도 다 들어올 수 있다 | 어떤 타입도 다 들어올 수 있다 |
| 아무 타입이나 다 받아요. | 단. 저는 검사된 타입만 받아요. |

그렇다고 반드시 <> 이 꺾쇠괄호 안에 명시해줄 필요는 없다 왜냐하면 생략을 한다면 컴파일 과정에서 알아서 인수보고 타입을 추론해 주기 때문이다.

하지만 제네릭을 사용할 때 특정 타입을 특정하지 않을 경우 특정한 타입에만 들어있는 값을 참조하는것은 에러를 유발한다.

만약 특정 요소 타입을  알 수 없을 경우엔 제네릭타입의 기본값을 추가할 수 있다. 

```tsx
function printLength<T>(value: T): number {
  return value.length; //오류 발생 왜냐하면 길이라는 속성은 배열에만 존재하기 떄문이다.
  //만약 길이가 없는 넘버타입이 들어오면 에러가 발생하기 때문
}

//그럴때 사용하는게 기본값 설정
function printLength<T extends { length: number }>(value: T): number {
  return value.length; 
}
//이렇게 길이를 설정해두면 어떤 값이 오더라도 특정값에 대해서 대응이 가능하기 때문에 오류가 발생안함

```

## 제네릭 사용법

1. **함수의 제네릭**
    1. 어떤 함수의 매개변수, 변환값에 제네릭을 사용하는데 타입에 들어오는 자리에 따라서 함수가 적절하게 사용될 수 있다.
    2. 함수 예시
    
    ```tsx
    type Identity<T> = (value: T) => T;
    
    const stringIdentity: Identity<string> = (value) => value;
    const numberIdentity: Identity<number> = (value) => value;
    
    console.log(stringIdentity("hello")); // "hello"
    console.log(numberIdentity(123));     // 123
    ```
    
2. **호출 시그니처의 제네릭**
    1. 개념적으로는 함수 의 매개변숴와 변환하는 타입을 미리 선언하는것을 말한다. 
    2. 이점 : 제네릭을 어디에 사용하냐에 따라 타입의 범위 제네릭 타입을 어느 시점에 구체적으로 한정할지 결정이 가능하다. 또한 어떤 타입이든 다 가져와서 쓸 수 있다.
    3. 호출 시그니처 예시
    
    ```tsx
    //책의 예시코드가 너무 복잡하고 이해가 잘 안가서 제가 이해한 바탕으로 코드를 작성해봤습니다
    
    //호출 시그니처에서의 예시
    interface greetingWord<T> {
    	(value : T) : T; //T라는 인자를 받아서 T를 다시 리턴하는 타입 인터페이스
    	//어떤 타입을 명시해주냐에 따라 어떻게 들어올지 예측간
    }
    
    function sayHello<T>(value: T) : T{ //제네릭 함수를 설정하므로 파라미터에 따라 어떤 값을 받아올지를 설정
    	return value; 
    }
    console.log(sayHello("안녕하세요"));// 안녕하세요 출력
    
    //그러면 화살표 함수에서는? 인터페이스가 있을 때 타입을 명시해줘야함
    const sayHi: greetingWord<string> = (value) => return value;
    
    console.log(sayHi("하이요"))//하이요 출력
    ```
    
     <T>(value: T): T 이렇게 하는 이유는?
    
    <T> = 제네릭 타입 선언 
    
    (value: T) =  T 라는 타입을 갖는다
    
    : T = 리턴값도 T 이다.
    
3. **클래스**
    1. 외부에서 입력된 타입을 클래스 내부에 적용이 가능한 클래스이다. 함수와 호출 시그니처에서 쓰이는 것 처럼 클래스에서 쓰이는 모습
    2. 예시
    
    ```tsx
    //일반적인 클래스
    class animal {
    	  sound(): string {
        return "동물이 소리를 낸다";
      }
    }
    
    class Dog extends Animal {
      bark(): string {
        return "멍멍!";
      }
    }
    
    const dog = new Dog();
    console.log(dog.sound()); //동물이 소리를 낸다 출력
    console.log(dog.bark());  //멍멍! 출력
    
    //제네릭 클래스
    
    class animal<T> {
    	  sound(value : T) {
        return value;
      }
    }
    
    class Dog extends Animal {
      bark(): string {
        return "멍멍!"; //한가지 값으로만 고정
      }
    }
    
    const dog = new Dog();
    console.log((dog.sound("왈멍")); //왈멍 출력
    console.log((dog.bark()); //멍멍! 출력
    
    ```
    
4. **제한된 제네릭**
    1. 타입스크립트에서 제한된 제네릭의 의미는 타입 매개변수에 대한 제약 조건을 지정하는 것이다 
    2. 코드로 알아보자 
    
    ```tsx
    type computer<Key extends string> = ~~~~ //이런 모습으로 사용됨
    //저렇게 키 다음 익스텐드 옆에 타입이 옴 이런 키를 바운드 타입 매개변수 라고 부르고
    //이 때 사용된 타입을 상한한계라고 부른다.
    ```
    
    이런 형태로 쓰이고 이 때 상속을 받을 수 있는 타입은 원시적인 타입 뿐 아니라 고급 타입들도 올 수 있고 인터페이스, 클래스 또한 올 수 있다.
    
5. **확장된 제네릭**
    1. 여러가지 타입을 상속받을 수 있고 타입 매개변수를 여러가지 둘 수 있다는 의미로 사용된다.
    2. 제한된 제네릭의 예시 코드처럼 만약 한가지로만 제한을 해버린다면 제네릭 코드의 유연함이 사라져서 제네릭의 큰 장점이 사라진다. 
    3. 이 때 사용할 수 있는데 바로 유니온 타입을 상속해서 사용하는 방법이 있다.
    4. 주의할 부분은 타입 매개변수가 여러가지 일 때 처리가 불가능해서 매개변수를 더 추가하여 사용한다.
    
    ```tsx
    //유니온타입 상속
    type Fruit = "apple" | "banana" | "orange";
    
    type fruitJuice<F extends Fruit> = {
      fruit: F;
      color: string;
     }
    
    //이런식으로 타입을 연장해서 유니온 타입처럼 쓰는것이다
    type CustomRecord<Key extends string, Value> = {
      [K in Key]: Value;
    };
    
    type LabeledValue<Key extends string, Value extends number | string> = {
      label: Key;
      value: Value; //이런식으로 타입 제약을 걸로 타입을 여러가지로 확장도 가능함
    };
    ```
    
6. **제네릭 예시**
    
    앞서 설명한 예시들이 제네릭을 사용하는 경우기 때문에 사용하지 않는 경우를 알아보자.
    
    **왜 와이? : 제네릭을 사용하면 코드가 넘 복잡해지기 때문이다.**
    
    어느 타입이 있다고 치고 그 타입이 함수의 값 변화로만 사용 될 때 즉 받아오는 데이터가 명확하고 복잡하지 않을 경우 단순하게 타입을 선언하는것으로 코드를 단순하게 만들 수 있다.
    
    **ANY 사용**
    
    any타입을 사용한다면.. 제네릭을 사용하는 이점이 없어진다고 책은 설명한다. 그도 그럴것이 제네릭을 사용하는 이유가 코드의 재사용성 및 타입 추론, 코드 안정성을 확보하기 위해서 사용하는 것인데 any를 사용한다면 이런 이점이 사라지므로 안쓰는것 못하다고 생각한다.
    
    **가독성을 고려하지 않은 사용**
    
    ```tsx
    type DeepStructure<T, U extends Record<string, T[]>> = {
      meta: U;
      value: T;
    }; //이러면 좀 알아보기가 어려워요,
    ```
    
    **제네릭을 잘 쓰려면**
    
    | 항목 | 설명 |
    | --- | --- |
    
    | 이름 명확히 | `T`, `U`보다는 `Value`, `Result`, `Payload`, `Data` 등 의미 있는 이름 |
    | --- | --- |
    | 필요한 경우만 사용 | 단순한 함수엔 불필요한 제네릭은 피함 |
    | 중첩 피하기 | 너무 복잡한 제네릭보다는 중간 타입으로 분리 |
    | default 타입 활용 | `<T = DefaultType>` 이런 식으로 기본값도 지정 가능 |
    | 제약 명확히 하기 | `<T extends SomeType>` 으로 범위 제한해서 타입 안전하게 |
    
    이렇게 하면 가독성을 좋게 쓸 수 있다.